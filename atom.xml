<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yooinn.github.io/</id>
    <title>Jiank</title>
    <updated>2019-10-10T15:10:03.876Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yooinn.github.io/"/>
    <link rel="self" href="https://yooinn.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://yooinn.github.io//images/avatar.png</logo>
    <icon>https://yooinn.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Jiank</rights>
    <entry>
        <title type="html"><![CDATA[mongo数据库]]></title>
        <id>https://yooinn.github.io//post/mongo-shu-ju-ku</id>
        <link href="https://yooinn.github.io//post/mongo-shu-ju-ku">
        </link>
        <updated>2019-10-10T13:20:24.000Z</updated>
        <content type="html"><![CDATA[<p><strong>mongo入门命令</strong></p>
<pre><code>show dbs  查看当前的数据库
 use databaseName 选库
show collections 查看当前库下的collection

</code></pre>
<p>如何创建库?<br>
Mongodb的库是隐式创建,你可以use 一个不存在的库，然后在该库下创建collection,即可创建库<br>
db.createCollection(‘collectionName’)<br>
即可创建一个集合。<br>
其实在MongoDB中，collection也是可以隐身创建的<br>
db.collectionName.insert(document)<br>
如何删除数据库和集合？<br>
db.collectionName.drop()//删除集合<br>
db.dropDatabase()//删除数据库</p>
<p>MongoDB基础增删改查操作</p>
<pre><code>1、增：insert方法
首先要明确一点，MongoDB存储的时文档，文档其实就是json格式的对象。
语法：
db.collectionName.isnert(document)
增加单篇文档：
db.collectionName.insert({title:’nice day’})
增加单个文档,并指定_id
db.collectionName.insert({_id:8,age:78,name:’lisi’})
增加多个文档
db.collectionName.insert(
[
{time:'friday',study:'mongodb'},
{_id:9,gender:'male',name:'QQ'}
]
)
2、删除：remove
语法:
 db.collection.remove(查询表达式, 选项)
选项是指  {justOne:true/false},是否只删一行, 默认为false
注意：
1: 查询表达式依然是个json对象 {age:20} where age =20   where age&gt;20
2: 查询表达式匹配的行,将被删掉.
3: 如果不写查询表达式,collections中的所有文档将被删掉
例1:删除stu表中 sn属性值为’001’的文档
 db.stu.remove({sn:’001’})
例2: 删除stu表中gender属性为m的文档,只删除1行.
db.stu.remove({gender:’m’,true});

3、更新：update
语法: db.collection.update(查询表达式,新值,选项)

改谁? --- 查询表达式
改成什么样? -- 新值 或 赋值表达式
操作选项 ----- 可选参数
例:
db.news.update({name:'QQ'},{name:'MSN'});
是指选中news表中,name值为QQ的文档,并把其文档值改为{name:’MSN’},结果: 文档中的其他列也不见了,改后只有_id和name列了，即--新文档直接替换了旧文档,而不是修改
如果是想修改文档的某列,可以用$set关键字：
db.collectionName.update(query,{$set:{name:’QQ’}})
修改时的赋值表达式
$set 修改某列的值
$unset 删除某个列
$rename 重命名某个列
$inc 增长某个列
Option的作用:{upsert:true/false,multi:true/false}
Upsert---是指没有匹配的行,则直接插入该行.
例:
db.stu.update({name:'wuyong'},{$set:{name:'junshiwuyong'}},{upsert:true});
如果有name=’wuyong’的文档,将被修改，如果没有,将添加此新文档
db.news.update({_id:99},{x:123,y:234},{upsert:true});
没有_id=99的文档被修改,因此直接插入该文档
multi: 是指修改多行(即使查询表达式命中多行,默认也只改1行,如果想改多行,可以用此选项)
db.news.update({age:21},{$set:{age:22}},{multi:true});
    则把news中所有age=21的文档,都修改
4、查: find
语法: db.collection.find(查询表达式,查询的列);
db.collections.find(表达式,{列1:1,列2:1});
    在查询的列参数中，1表示显示，0表示不显示
例1:db.stu.find()
    查询所有文档 所有内容
例2: db.stu.find({},{gendre:1})
    查询所有文档,的gender属性 (_id属性默认总是查出来)
例3: db.stu.find({},{gender:1, _id:0})
    查询所有文档的gender属性,且不查询_id属性
例4: db.stu.find({gender:’male’},{name:1,_id:0});
    查询所有gender属性值为male的文档中的name属性
    2. MongoDB AND 条件
    MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，及常规 SQL 的 AND 条件。类似于 WHERE 语句：WHERE by='优就业' AND title='MongoDB 教程。
    语法格式如下：
db.col.find({key1:value1， key2:value2}).pretty()
    3、常用方法：
limit()
db.COLLECTION_NAME.find().limit(NUMBER)
skip()
db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)
sort()
db.COLLECTION_NAME.find().sort({KEY:1})
count()
 db.mycol.count()
5、查询表达式:
最简单的查询表达式
| Model| 命令| Model | 命令|
| --------- | -------- | -----: | --: |
|  $lt| 小于  |  $lte |   小于等于 |
| $gt| 大于|   $gte|   大于等于 |
| $ne --- != | 查询表达式 
|  |     |    |    |


    {filed:value} ,是指查询field列的值为value的文档
$lt小于
$lte小于等于
$gt 大于
$gte大于等于
$ne --- != 查询表达式
{field:{$nq:value}} ---作用：查filed列的值 不等于 value 的文档
db.goods.find({cat_id:{$nq:3}},{cat_id:1,goods_id:1,goods_name:1,_id:0})
//查询cat_id不等3的数据
$nin --&gt; not in
db.stu.find({age:{$nin:[1,16]}})
$all：指数组所有单元匹配，就是指我指定的内容都要有，通过一个list来指定
db.stu.insert({name:'xt',age:99,hobby:['aa','bb']})
db.stu.find({hobby:{$all:['aa','bb']}},{name:1,age:1,_id:0})
$exists
        语法: {field:{$exists:1}}
        作用: 查询出含有field字段的文档
 db.stu.find({hobby:{$exists:1}})
$nor
{$nor,[条件1,条件2]} 是指  所有条件都不满足的文档为真返回
$and
        {$and,[条件1,条件2]} 是指  所有条件都满足，就为真
$or
        {$or,[条件1,条件2]} 是指  条件1和条件2有一个满足，就为真
</code></pre>
<p><strong>例子:</strong></p>
<h1 id="取出不属于第3栏目且不属于第11栏目的商品and-nin和nor分别实现">//取出不属于第3栏目且不属于第11栏目的商品($and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">nin和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">和</span></span></span></span>nor分别实现)</h1>
<p>db.goods.find({<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …:[{shop_price:{'>and:[{shop_price:{</span>lt:500}},{shop_price:{<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 7: gt:100}̲}]},{_id:0,shop…'>gt:100}}]},{_id:0,shop_price:1})
db.goods.find({</span>nor:[{cat_id:3},{cat_id:11}]},{cat_id:1})<br>
db.goods.find({cat_id:{$nin:[3,11]}},{cat_id:1})</p>
<h1 id="取出价格大于100且小于300或者大于4000且小于5000的商品">//取出价格大于100且小于300,或者大于4000且小于5000的商品()</h1>
<p>db.goods.find({<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: or:[{'>or:[{</span>and:[{shop_price:{<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 7: gt:100}̲},{shop_price:{'>gt:100}},{shop_price:{</span>lt:300}}]},{<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …:[{shop_price:{'>and:[{shop_price:{</span>gt:4000}},{shop_price:{$lt:5000}}]}]})</p>
<h1 id="取出goods_id5-1-即1611这样的商品">取出goods_id%5 == 1, 即,1,6,11,..这样的商品</h1>
<p>db.goods.find({goods_id:{$mod:[5,1]}},{goods_id:1})</p>
<p>格式db.表明.find({表内容:值|条件})</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 爬虫框架scrapy笔记]]></title>
        <id>https://yooinn.github.io//post/python-pa-chong-kuang-jia-scrapy-bi-ji</id>
        <link href="https://yooinn.github.io//post/python-pa-chong-kuang-jia-scrapy-bi-ji">
        </link>
        <updated>2019-10-10T00:49:21.000Z</updated>
        <content type="html"><![CDATA[<pre><code>scrapy startproject name 创建项目
scrapy genspider spider_name 创建爬虫文件
编写代码
scrapy crawl spider_name 运行爬虫
</code></pre>
<pre><code>项目文件下所有py的功能介绍：
scrapy.cfg：配置文件
spiders：存放你Spider文件，也就是你爬取的py文件
items.py：相当于一个容器，和字典较像
middlewares.py：定义Downloader Middlewares(下载器中间件)和Spider Middlewares(蜘蛛中间件)的实现
pipelines.py:定义Item Pipeline的实现，实现数据的清洗，储存，验证。
settings.py：全局配置
</code></pre>
<p><strong>一个例子</strong></p>
<pre><code>boss直聘项目：
1.创建项目
scrapy startproject name 创建项目
2.创建spider
scrapy genspider spider_name 创建爬虫文件
3.robots改为false
项目里settings.py里面
	COOKIES_ENABLED = False
4.设置请求头
	DEFAULT_REQUEST_HEADERS = {
5.添加待爬取的url到start_urks
6、测试parse方法能否爬取到页面数据。如果不能分析。
	这个项目需要添加cookie，如果想要设置自定义的cookie，需要将：
	COOKIES_ENABLED = False
7、爬取数据：
	1、在items.py中定义爬取字段
	2.在parse方法中实例化items
	item = BosszpItem()
	3、提取item的每个字段，并设置到item中。
	item['name'] = name
	item['salary'] = salary
	4、设置好之后，yield item，开始编写pipeline的内容
	5、写好pipeline之后，需要配置才能生效。
	
中间件如何设置：
	1.新建一个文件，比如：mymidderware.py
	2.在这个类中，主要实现：
	    def process_request(self, request, spider):
        if spider.name=='tencent':
            print('============in middle============')
            self.driver.get(request.url)
            self.wait.until(EC.presence_of_element_located((By.XPATH,'//div[@class=&quot;search-content&quot;]')))
            html = self.driver.page_source
            #将页面内容包装到一个response对象中
            return HtmlResponse(request.url,body=html,encoding='utf-8',request=request)
        print('====222======')
        return None
	3.配置：
	DOWNLOADER_MIDDLEWARES = {
   'bosszp.MyMiddleWares.MiddleWares_Tencent': 543,
	}

LOG_ENABLED=True
LOG_ENCODING='utf-8'
LOG_FILE='tencent.log'
LOG_LEVEL = 'INFO'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python中MD5加密]]></title>
        <id>https://yooinn.github.io//post/python-zhong-md5-jia-mi</id>
        <link href="https://yooinn.github.io//post/python-zhong-md5-jia-mi">
        </link>
        <updated>2019-09-27T01:22:05.000Z</updated>
        <content type="html"><![CDATA[<p>Python中生成MD5</p>
<h1 id="由于md5模块在python3中被移除">由于MD5模块在python3中被移除</h1>
<h1 id="在python3中使用hashlib模块进行md5操作">在python3中使用hashlib模块进行md5操作</h1>
<pre><code>import hashlib

# 待加密信息
str = '123456'
# 创建md5对象
hl = hashlib.md5()
#更新hash对象的值，如果不使用update方法也可以直接md5构造函数内填写
#md5_obj=hashlib.md5(&quot;123456&quot;.encode(&quot;utf-8&quot;)) 效果一样
hl.update(str.encode(&quot;utf-8&quot;))
print('MD5加密前为 ：' + str)
print('MD5加密后为 ：' + hl.hexdigest())
</code></pre>
<p><strong>MD5双重加密</strong></p>
<pre><code>md5_obj=hashlib.md5(&quot;123456&quot;.encode(&quot;utf-8&quot;))
str1=md5_obj.hexdigest() #加密1次
obj2=hashlib.md5(str1.encode(&quot;utf-8&quot;))
str2=obj2.hexdigest()#加密2次
print(str2) #双重加密后，同样解密开
</code></pre>
<p><strong>MD5加盐值(SALT)</strong></p>
<pre><code>from random import Random  
import hashlib
  
# 获取由4位随机大小写字母、数字组成的salt值  
def create_salt(length = 4):  
    salt = ''  
    chars = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789'  
    len_chars = len(chars) - 1  
    random = Random()  
    for i in range(length):  
        # 每次从chars中随机取一位  
        salt += chars[random.randint(0, len_chars)]  
    return salt  
  
# 获取原始密码+salt的md5值  
def create_md5(pwd,salt):  
    md5_obj = hashlib.md5()  
    md5_obj.update((pwd + salt).encode(&quot;utf-8&quot;))  
    return md5_obj.hexdigest()  
  
# 原始密码  
pwd = '123456'  
# 随机生成4位salt  
salt = create_salt()  
# 加密后的密码  
md5 = create_md5(pwd, salt)  
  
print('[pwd]\n',pwd ) 
print('[salt]\n', salt)  
print('[md5]\n', md5) 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS下编译安装Python3教程]]></title>
        <id>https://yooinn.github.io//post/centos-xia-bian-yi-an-zhuang-python3-jiao-cheng</id>
        <link href="https://yooinn.github.io//post/centos-xia-bian-yi-an-zhuang-python3-jiao-cheng">
        </link>
        <updated>2019-09-20T13:35:12.000Z</updated>
        <content type="html"><![CDATA[<p>到官网获取最新版的Python3 下载地址 https://www.python.org/downloads/source/ ， 现在最新版是Python3.7.2</p>
<p>下载完成后，解压,执行命令：</p>
<pre><code>
[www@pythontab.com]$ wget --no-check-certificate https://www.python.org/ftp/python/3.7.2/Python-3.7.2.tgz
[www@pythontab.com]$ xz -d Python-3.7.2.tgz
[www@pythontab.com]$ tar -xzvf Python-3.7.2.tgz
2. 编译前配置
[www@pythontab.com]$ cd Python-3.7.2/
[www@pythontab.com]$ ./configure --prefix=/usr/local/python3.7 --enable-optimizations
</code></pre>
<p>上面的命令解释一下：</p>
<p>--prefix 选项是配置安装的路径，如果不配置该选项，安装后可执行文件默认放在/usr/local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr/local/share。</p>
<p>如果配置--prefix，如：./configure --prefix=/usr/local/python3.7可以把所有资源文件放在/usr/local/python3.7的路径中，便于管理。</p>
<p>--enable-optimizations 是优化选项（LTO,PGO 等）加上这个 flag 编译后，性能有 10% 左右的优化,但是这会明显的增加编译时间。</p>
<p>./configure命令执行完毕之后创建一个文件 Makefile, 供下面的make命令使用,执行make install之后就会把程序安装到我们指定的文件夹中去。</p>
<ol start="3">
<li>执行编译和安装</li>
</ol>
<pre><code>[www@pythontab.com]$ make &amp;&amp; make install
安装完成之后进入到/usr/local/python3.7目录,可以看到Python的可执行文件目录bin等相关目录了。
</code></pre>
<ol start="4">
<li>增加软连接<br>
执行完上一步，你可能还不能直接运行Python3命令，因为你的/usr/local/可能不在PATH环境变量中， 我们可以通过增加软连接的方式来解决这个问题</li>
</ol>
<p>执行如下命令：</p>
<pre><code>
[www@pythontab.com]$ ln -s /usr/local/python3.7/bin/python3.7 /usr/bin/python3
[www@pythontab.com]$ ln -s /usr/local/python3.7/bin/python3.7 /usr/bin/python3.7
这时候你再执行Python3或者Python3.7就可以运行了

[www@pythontab.com]$ python3
Python 3.7.2 (default, Mar  3 2019, 13:15:50) 
[GCC 4.4.7 20120313 (Red Hat 4.4.7-16)] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
</code></pre>
<blockquote>
<blockquote>
<blockquote></blockquote>
</blockquote>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django框架静态文件使用/中间件/禁用ip功能实例详解]]></title>
        <id>https://yooinn.github.io//post/django-kuang-jia-jing-tai-wen-jian-shi-yong-zhong-jian-jian-jin-yong-ip-gong-neng-shi-li-xiang-jie</id>
        <link href="https://yooinn.github.io//post/django-kuang-jia-jing-tai-wen-jian-shi-yong-zhong-jian-jian-jin-yong-ip-gong-neng-shi-li-xiang-jie">
        </link>
        <updated>2019-09-20T13:14:23.000Z</updated>
        <content type="html"><![CDATA[<p>静态文件</p>
<p>一、静态文件的使用</p>
<p>静态文件：网页中使用的css，js，图片</p>
<p>静态文件的使用：</p>
<p>在项目下创建静态目录，比如：static，导入静态文件（HTML、CSS、js）</p>
<p>在setting.py中配置静态目录</p>
<pre><code>
# 通过此url来引用静态文件，可以隐藏服务器的文件的实际保存目录
STATIC_URL = '/abc/'
# 指定静态文件所在的物理目录
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]
</code></pre>
<p>通过setting.py中的STATIC_URL的值来引用静态文件，好处：可以隐藏服务器的文件的实际保存目录。比如：</p>
<pre><code>&lt;img src=&quot;/abc/image/mm.jpg&quot; /&gt;
&lt;script src=&quot;/abc/js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>二、使用static标签动态引用</p>
<p>上述写法是硬编码，存在维护问题，可以使用static标签动态引用</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
{% load staticfiles %}
&lt;head&gt;
...
&lt;/head&gt;
&lt;body&gt;
动态引用：&lt;br/&gt;
&lt;img src=&quot;{% static 'image/mm.jpg' %}&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>中间件</p>
<p>MIDDLEWARE: 中间件</p>
<p>一、案例： 禁止指定ip地址的访问</p>
<p>使用request对象的META属性，可以获取用户访问的ip地址：</p>
<p>request.META.get('REMOTE_ADDR')</p>
<p>二、中间件</p>
<p>中间件： django框架预留的接口，可以控制请求和响应的过程。Django在中间件中预置了6个方法，这些方法会在不同的阶段执行，对输入或输出进行干预。</p>
<figure data-type="image" tabindex="1"><img src="https://files.jb51.net/file_images/article/201907/2019722114704117.png?2019622114834" alt=""></figure>
<p>初始化：无需任何参数，服务器响应第一个请求的时候调用一次：</p>
<p>def <strong>init</strong>():<br>
pass</p>
<p>处理请求前(url匹配前)调用： 返回None或HttpResponse对象</p>
<p>def process_request(self, request):<br>
pass</p>
<p>url匹配后视图函数处理前调用： 返回None或HttpResponse对象</p>
<p>def process_view(self, request, view_func, view_args, view_kwargs):<br>
pass</p>
<p>视图函数出异常时调用：返回一个HttpResponse对象</p>
<p>def process_exception(self, request, exception):<br>
return response</p>
<p>视图函数处理后，模板响应处理前调用： 返回实现了render方法的响应对象</p>
<p>def process_template_response(self, request, response):<br>
pass</p>
<p>视图函数返回TemplateReponse时才会调用，返回HttpResponse对象不会调用</p>
<p>视图函数处理后，返回内容给浏览器前调用：返回HttpResponse对象</p>
<p>def process_response(self, request, response):<br>
return response</p>
<p>禁用ip功能</p>
<p>在MyMiddleware的process_view方法中，新增代码如下：</p>
<p>class MyMiddleware(object):<br>
...<br>
exclude_ips = ['127.0.0.1']<br>
def process_view(self, request, view_func, view_args, view_kwargs):<br>
print('--process_view--')<br>
# 禁用ip，以下代码也可以添加到process_request方法<br>
ip = request.META.get('REMOTE_ADDR')<br>
if ip in exclude_ips:<br>
return HttpResponse('禁止访问')</p>
<p>异常处理</p>
<p>异常处理： 视图函数执行出错之后，会调用中间件的process_exception方法，可以在该方法中执行异常操作。</p>
<p>在index视图函数中，添加执行出错代码：</p>
<p>def index(request):<br>
&quot;&quot;&quot;进入首页&quot;&quot;&quot;<br>
print('=<mark><mark>index</mark></mark>')</p>
<h1 id="添加出错代码">添加出错代码</h1>
<p>aa = None<br>
print('aa='+ aa)<br>
return render(request, 'app01/index.html')</p>
<p>在前面编写的MyMiddleware中： 添加处理异常的中间件方法，并注释前面的拦截ip的拦截：</p>
<h1 id="middlewarepy">middleware.py</h1>
<p>class MyMiddleware(object):<br>
...<br>
def process_view(self, request, view_func, view_args, view_kwargs):<br>
print('-------process_view')<br>
# # 禁止ip访问<br>
# ip = request.META.get('REMOTE_ADDR')<br>
# if ip in exclude_ips:<br>
#   return HttpResponse('禁止访问')<br>
def process_exception(self, request, exception):<br>
print('-----process_exception')</p>
<p>访问首页，查看服务器，发现：处理异常的中间件方法process_exception执行了</p>
<p>处理出错： 在process_exception方法中返回HttpResponse对象就可以了：</p>
<h1 id="middlewarepy-2">middleware.py</h1>
<p>class MyMiddleware(object):<br>
...<br>
def process_exception(self, request, exception):<br>
print('-----process_exception')<br>
return HttpResponse('运行出错了：%s' % exception)</p>
<p>希望本文所述对大家基于Django框架的Python程序设计有所帮助。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django中间件拦截未登录url实例详解]]></title>
        <id>https://yooinn.github.io//post/django-zhong-jian-jian-lan-jie-wei-deng-lu-url-shi-li-xiang-jie</id>
        <link href="https://yooinn.github.io//post/django-zhong-jian-jian-lan-jie-wei-deng-lu-url-shi-li-xiang-jie">
        </link>
        <updated>2019-09-20T13:13:48.000Z</updated>
        <content type="html"><![CDATA[<p>1.利用装饰器在视图中拦截未登录的url</p>
<p>@login_required(login_url='/user/login/')<br>
def homepage(request):<br>
pass<br>
这种方法适合于程序中只有少数几个需要登录拦截的url。</p>
<ol start="2">
<li>利用中间件技术拦截未登录的url</li>
</ol>
<p>2.1 在settings.py添加MIDDLEWARE设置：middleware.LoginCheckMiddleware</p>
<p>MIDDLEWARE = [<br>
'django.middleware.security.SecurityMiddleware',<br>
'django.contrib.sessions.middleware.SessionMiddleware',<br>
'django.middleware.common.CommonMiddleware',</p>
<h1 id="djangomiddlewarecsrfcsrfviewmiddleware">'django.middleware.csrf.CsrfViewMiddleware',</h1>
<p>'django.contrib.auth.middleware.AuthenticationMiddleware',<br>
'django.contrib.messages.middleware.MessageMiddleware',<br>
'django.middleware.clickjacking.XFrameOptionsMiddleware',</p>
<h1 id="url登录拦截中间件">url登录拦截中间件</h1>
<p>'middleware.LoginCheckMiddleware',<br>
]<br>
2.2 在项目目录下创建middleware.py文件，文件中创建拦截类：LoginCheckMiddleware</p>
<p>import re<br>
from django.http import JsonResponse<br>
from django.shortcuts import HttpResponseRedirect<br>
from django.utils.deprecation import MiddlewareMixin</p>
<p>class LoginCheckMiddleware(MiddlewareMixin):<br>
def process_request(self, request):<br>
# | 分隔要匹配的多个url，从左到右匹配，有匹配就返回匹配值，否则返回None。<br>
pattern = r'^(/<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">/</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mo>[</mo><mn>0</mn><mo>−</mo><mn>9</mn><mo>]</mo><mo>+</mo><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">|/user/user/[0-9]+/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span></span></span></span>|/user/user/$|/user/getuserall|/user/get_token_code|/user/update_phone_no|/stock|/future)'</p>
<pre><code># 如果 request.path 的开始位置能够找到这个正则样式的任意个匹配，就返回一个相应的匹配对象。
# 如果不匹配，就返回None
match = re.search(pattern, request.path)
# 需要拦截的url
if match and not request.user.is_authenticated:
  print('用户未登录URL拦截 &gt;&gt;: ', request.path)
</code></pre>
<p># 主页未登录<br>
if request.path == '/':<br>
return HttpResponseRedirect('/user/login/')<br>
# ajax请求未登录<br>
else:<br>
return JsonResponse({'status': False, 'info': '用户未登录!'})<br>
应用了正则表达式过滤需要拦截的url。</p>
<p>由于ajax请求不能重定向，所以对于ajax请求的url拦截返回json数据，由前端处理返回的结果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python写一个基于MD5的文件监听程序]]></title>
        <id>https://yooinn.github.io//post/python-xie-yi-ge-ji-yu-md5-de-wen-jian-jian-ting-cheng-xu</id>
        <link href="https://yooinn.github.io//post/python-xie-yi-ge-ji-yu-md5-de-wen-jian-jian-ting-cheng-xu">
        </link>
        <updated>2019-09-20T12:28:41.000Z</updated>
        <content type="html"><![CDATA[<p>前述</p>
<p>写了一个基于MD5算法的文件监听程序，通过不同的文件能够生成不同的哈希函数，来实现实现判断文件夹中的文件的增加、修改、删除和过滤含有特定字符的文件名的文件。</p>
<p>需求说明<br>
需要实现对一个文件夹下的文件的增加、修改和删除的监控， 一旦发生上述操作，则进行提示。可以选择过滤掉文件名中的特定字符和只监听文件名中含有特定字符的文件。</p>
<p>简述<br>
首先，关于文件的增加、修改、删除的反馈，可以想到利用MD5等类似的加密算法，因为文件本身可以生成哈希值，只要文件内容或者文件名被修改过，就会生成和修改之前的哈希值不同的值，因此可以利用dict来存储，一个文件名对应一个哈希值来存储。其中增加和删除就对应一个新增加的键值对和一个减少的键值对，而修改则可以理解为删除了旧的文件、增加了一个新的文件。<br>
MD5算法可以直接利用第三方的 hashlib 库来实现</p>
<p>m = hashlib.md5()<br>
myFile = open(full_path, 'rb')<br>
for line in myFile.readlines(): #以行为单位不断更新哈希值，避免文件过大导致一次产生大量开销<br>
m.update(line) #最后可以得到整个文件的哈希值<br>
第二，关于滤掉文件名中的特定字符和只监听文件名中含有特定字符的文件的功能，这个其实非常简单，只需要用 list 分别对需要过滤和必须存在字符串进行存储， 然后利用标志位和字符串的子串包含性进行判断就可以了，只有满足条件的文件可以产生哈希值，产生哈希值也就意味着被监听了。<br>
判断字符串中是否含有字串最常用的方法是 in 和 string 中的 find 方法，这里就不再赘述，可以直接看下面的代码</p>
<p>第三，因为要同时监控多个文件夹，所以必须要利用到线程来处理，创建一个线程池来存储线程， 线程利用了 threading 库，并且实现一个线程类来处理线程的操作<br>
class myListener(threading.Thread):<br>
thread1 = myListener(mydir, json_list_include, json_list_exclude) #生成线程<br>
说明<br>
需要额外说明的一点是，在传输需要监听的文件夹、必须包含的字段以及过滤字段的时候，我这里是利用配置文件的形式来存储的。说到底，是利用 toml 格式的数据进行的传输，toml格式和 json格式相比，用户的可读性更强一些，为了便于博客展示，因此利用了 toml 格式</p>
<p>首先利用代码生成了一下toml格式的文件，以后再想用的话，程序打包之后，可以直接修改配置文件来实现对程序的控制。</p>
<p>#!/usr/bin/env python</p>
<h1 id="-codingutf-8-">-<em>- coding:utf-8 -</em>-</h1>
<h1 id="author-jyroooy">Author: JYRoooy</h1>
<p>import collections<br>
import json<br>
import toml<br>
if <strong>name</strong> == '<strong>main</strong>':<br>
myOrderDict = collections.OrderedDict<br>
myOrderDict = {'dict':[{'path':'E:/testing', 'include':['log_'], 'exclude': ['.swp', '.swx', 'tmp']},{'path':'E:/tmp', 'include':['.record'], 'exclude': ['.tmp']}]}<br>
myToml = toml.dump(myOrderDict, open('E:/python/code/PythonProject/tomlConfig.txt','w+'))<br>
toml文件</p>
<p>格式说明， 一个 dict 对应一个监听的文件夹和需要 过滤(exculde) 和 含有(include) 的字段，解释一下，这里的字段只是文件名的字段，监控 E:/testing 目录下的文件，要包含 log_ 字段的文件，且不包含 .swp .swx .tmp 字段的文件， 并且监控 E:/tmp 目录下的文件，要包含 .record 字段的文件，且不包含 .tmp 的文件。<br>
<img src="https://files.jb51.net/file_images/article/201903/2019311100740411.png?201921110747" alt=""><br>
代码<br>
完整程序的代码，具体解释可以看注释</p>
<pre><code>#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: JYRoooy
import toml
import hashlib
import os
import sys
import time
import importlib
import threading
importlib.reload(sys)

class myListener(threading.Thread):
 '''
 监听类
 '''
 def __init__(self, input_dir, filt_in, filt_ex): #文件夹路径，必须包含的字符，必须过滤的字符
 threading.Thread.__init__(self)
 self.input_dir = input_dir
 self.filt_in = filt_in
 self.filt_ex = filt_ex
 self.dict = {} #用来存储文件名和对应的哈希值
 self.file_list = [] #存储每一次扫描时的文件的文件名
 self.pop_list = [] #存储需要删除的文件名

 def run(self):
 while (1): #保证文件夹一直处于被监听的状态
  for cur_dir, dirs, files in os.walk(self.input_dir):
  if files != []:
   self.file_list = []
   for each_file_1 in files:
   each_file = each_file_1
   if self.filt_in: #判断文件名中是否有必须存在的字段
    flagone = 0
    for i in range(len(self.filt_in)):
    if self.filt_in[i] in each_file:
     flagone += 1
    if flagone == 0:
    continue

   if self.filt_ex: #判断文件名中是否有必须过滤掉的字段
    flagtwo = 0
    for i in range(len(self.filt_ex)):
    if self.filt_ex[i] in each_file:
     flagtwo = 1
    if flagtwo==1:
    continue

   self.file_list.append(each_file)
   full_path = os.path.join(cur_dir, each_file)
   m = hashlib.md5() #实例化md5算法

   myFile = open(full_path, 'rb')

   for line in myFile.readlines():
    m.update(line)
   if each_file not in self.dict.keys(): #如果当前的dict中没有这个文件，那么就添加进去
    self.dict[each_file] = m.hexdigest() #生成哈希值
    print('文件夹:' +cur_dir+ &quot;中的文件名为：&quot; + each_file + &quot;的文件为新文件&quot; + time.strftime('%Y-%m-%d %H:%M:%S',
           time.localtime(time.time())))
   if each_file in self.dict.keys() and self.dict[each_file] != m.hexdigest(): #如果当前dict中有这个文件，但是哈希值不同，说明文件被修改过，则需要对字典进行更新
    print('文件夹:' +cur_dir+ &quot;中的文件名为：&quot; + each_file + &quot;的文件被修改于&quot; + time.strftime('%Y-%m-%d %H:%M:%S',
           time.localtime(time.time())))
    self.dict[each_file] = m.hexdigest()
   myFile.close()
  pop_list = []
  for i in self.dict.keys():
   if i not in self.file_list: #当字典中有不在当前文件名列表中时，说明文件已经被删除
   print('文件夹:' +cur_dir+ '中的文件名为:' + i + &quot;的文件已被删除!!!&quot; + time.strftime('%Y-%m-%d %H:%M:%S',
          time.localtime(time.time())))
   pop_list.append(i)
  for i in pop_list:
   self.dict.pop(i)

  time.sleep(2)

if __name__ == '__main__':
 threads = [] #用来存储线程的线程池
 with open('E:/python/code/PythonProject/tomlConfig.txt','r+') as f: #读取toml格式的文件，并分解格式
 mytoml = toml.load(f)
 myList = mytoml['dict']
 for i in range(len(myList)): #因为可能同时需要监听多个文件夹，所以利用线程池处理多线程
  json_list_include = []
  json_list_exclude = []
  mydir = myList[i]['path']
  for sublist in range(len(myList[i]['include'])):
  json_list_include.append(myList[i]['include'][sublist])
  for sublist in range(len(myList[i]['exclude'])):
  json_list_exclude.append(myList[i]['exclude'][sublist])
  thread1 = myListener(mydir, json_list_include, json_list_exclude) #生成线程
  threads.append(thread1)

 for t in threads: #开启所有线程
  t.start();
</code></pre>
<p>运行结果<br>
两个文件夹中的文件<br>
<img src="https://files.jb51.net/file_images/article/201903/2019311100842641.png?201921110849" alt=""><br>
第一次运行程序， 可以看到已经按照过滤规则完成了过滤和监听<br>
<img src="https://files.jb51.net/file_images/article/201903/2019311100945510.png?201921110951" alt=""><br>
修改 loko.record 文件为 loko.re，再来看结果<br>
<img src="https://files.jb51.net/file_images/article/201903/2019311101001277.png?201921110107" alt=""></p>
<p>可以看到已经完成了监听，因为 loko.re 文件，并符合监听的规则，所以不做出监听，而我们前面说过，一个修改相当于一个删除和一个新建操作，所以监听程序提示原文件被删除了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django-simple-captcha 图形验证码模块]]></title>
        <id>https://yooinn.github.io//post/django-simple-captcha-tu-xing-yan-zheng-ma-mo-kuai</id>
        <link href="https://yooinn.github.io//post/django-simple-captcha-tu-xing-yan-zheng-ma-mo-kuai">
        </link>
        <updated>2019-09-20T06:56:49.000Z</updated>
        <content type="html"><![CDATA[<p>**一、引言 **<br>
        官方文档：django-simple-captcha</p>
<p>本博客谈不上深度，算是笔记和一些探索经验。主要是遇到了一个实际问题，在使用django-simple-captcha模块的时候，官网推荐使用django表单的形式去添加，django表单确实很方便，但是对于简单项目或者只需要django-simple-captcha模块的时候也没有太多的文档具体说明，这篇博客就说一下怎么单独使用django-simple-captcha模块。</p>
<p>目标：实现手动创建验证码和前端显示，后台手动验证，ajax请求。</p>
<p><strong>二、流程</strong><br>
1）安装 django-simple-captcha</p>
<p>pip install django-simple-captcha<br>
2）注册captcha</p>
<p>INSTALLED_APPS = [<br>
'django.contrib.admin',<br>
'django.contrib.auth',<br>
'django.contrib.contenttypes',<br>
'django.contrib.sessions',<br>
'django.contrib.messages',<br>
'django.contrib.staticfiles',<br>
'captcha',<br>
]<br>
也可以个性化定制，在 settings.py中添加如下代码，详情参考官方文档：</p>
<h1 id="设置-captcha-图片大小">设置 captcha 图片大小</h1>
<p>CAPTCHA_IMAGE_SIZE = (80, 45)</p>
<h1 id="字符个数">字符个数</h1>
<p>CAPTCHA_LENGTH = 4</p>
<h1 id="超时minutes">超时(minutes)</h1>
<p>CAPTCHA_TIMEOUT = 1<br>
3）执行数据迁移，生成数据表 captcha_captchastore</p>
<p>python manage.py migrate<br>
4）添加路由</p>
<p>urlpatterns = [<br>
path('admin/', admin.site.urls),<br>
# 图片验证码 路由<br>
path('captcha/', include('captcha.urls'))<br>
]<br>
再添加ajax刷新请求的二级路由，ajxa请求地址： /refresh_captcha/</p>
<p>path('refresh_captcha/', views.refresh_captcha),    # 刷新验证码，ajax<br>
本次django使用的是2.1.8版本，路由的写法可能有点不同，原理一样。</p>
<p>5）在views.py中添加代码，因为在我的项目中，设计到代码的复用问题，所以我创建验证码和验证单独做成函数</p>
<pre><code> 验证码需要导入的模块
from captcha.models import CaptchaStore
from captcha.helpers import captcha_image_url
from django.http import JsonResponse
 
# 创建验证码
def captcha():
    # 验证码，第一次请求
    hashkey = CaptchaStore.generate_key()
    image_url = captcha_image_url(hashkey)
    captcha = {'hashkey': hashkey, 'image_url': image_url}
    return captcha
		
 #验证码API接口
def refresh_captcha(request):
    # 响应
    return JsonResponse(captcha(), content_type='application/json')
 
# 验证验证码
def jarge_captcha(captchaStr, captchaHashkey):
    if captchaStr and captchaHashkey:
        try:
            # 获取根据hashkey获取数据库中的response值
            get_captcha = CaptchaStore.objects.get(hashkey=captchaHashkey) 
            # 如果验证码匹配
            if get_captcha.response == captchaStr.lower():  
                return True
        except:
            return False
    else:
        return False
</code></pre>
<p><strong>前端页面：</strong></p>
<pre><code>&lt;div class=&quot;form-group&quot;&gt;
    &lt;label for=&quot;id_password&quot;&gt;验证码&lt;/label&gt;
    &lt;div id=&quot;captcha_div&quot;&gt;
        &lt;input type=&quot;text&quot; name='captcha' class=&quot;form-control&quot; placeholder=&quot;Captcha&quot; required style=&quot;width: 55%;display: inline-block;margin-right: 8%;&quot;&gt;
        &lt;a href=&quot;#&quot; class=&quot;captcha&quot;&gt;&lt;img src=&quot;{{captcha.image_url}}&quot; alt=&quot;点击换一张&quot; id=&quot;id_captcha&quot;&gt;&lt;/a&gt;
        &lt;input value=&quot;{{captcha.hashkey}}&quot; name=&quot;hashkey&quot; type=&quot;hidden&quot; id=&quot;id_captcha_0&quot;&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p><strong>前端页面显示图片采用 src=&quot;{{captcha.image_url}}&quot;来获取：</strong></p>
<pre><code>&lt;script&gt;
        &lt;!-- 动态刷新验证码js --&gt;
        //网页加载时调用
        $(document).ready(function(){
            //网页加载时发送请求
            $.getJSON(&quot;/refresh_captcha/&quot;, function (result) {
                    $('#id_captcha').attr('src', result['image_url']);
                    $('#id_captcha_0').val(result['hashkey'])
                });
            //点击按钮触发,发送请求
            $('.captcha').click(function () {
                $.getJSON(&quot;/refresh_captcha/&quot;, function (result) {
                    $('#id_captcha').attr('src', result['image_url']);
                    $('#id_captcha_0').val(result['hashkey'])
                });
            });
        });
&lt;/script&gt;
</code></pre>
<p>效果<br>
<img src="https://i.loli.net/2019/09/20/9OueNLHPFosdRyr.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django templates 模板的语法]]></title>
        <id>https://yooinn.github.io//post/django-templates-mo-ban-de-yu-fa</id>
        <link href="https://yooinn.github.io//post/django-templates-mo-ban-de-yu-fa">
        </link>
        <updated>2019-09-20T01:10:22.000Z</updated>
        <content type="html"><![CDATA[<p>MVC 以及 MTV<br>
MVC:<br>
M : model --&gt;&gt; 存取数据(模型)<br>
V: view --&gt;&gt; 信息的展示(视图)<br>
C: controller --&gt;&gt; 逻辑的控制(控制器)<br>
MTV:<br>
M: model --&gt;&gt; ORM操作(模型)<br>
T: template --&gt;&gt; 模板(模板)<br>
V: view --&gt;&gt; 业务逻辑 (视图)<br>
变量<br>
取值顺序 : 字典Key ---&gt;&gt; 属性---&gt;&gt;方法---&gt;&gt;索引<br>
{{ new_name }} ——》 变量 新华出版社 字典或列表用 . 取值<br>
for循环for 标签带有一个可选的{% empty %} 从句，以便在给出的组是空的或者没有被找到时，可以有所操作。<br>
{% for person in person_list %}</p>
<p>{{ person.name }}</p>
<h1 id="循环取值">循环取值</h1>
<p>{% empty %}<br>
<p>sorry,no person here</p>   #  person_list 为空时 显示<br>
{% endfor %}<br>
if 标签 ：{% if %}会对一个变量求值，如果它的值是“True”（存在、不为空、且不是boolean类型的false值），对应的内容块会输出。<br>
{% if i &gt; 300 %}<br>
大于{{ i }}</p>
<p>{% elif i == 200 %}<br>
等于{{ i }}</p>
<p>{% else %}<br>
小于{{ i }}</p>
<p>{% endif %}<br>
.with：使用一个简单地名字缓存一个复杂的变量，当你需要使用一个“昂贵的”方法（比如访问数据库）很多次的时候是非常有用的<br>
{% with total=business.employees.count %}<br>
{{ total }} employee{{ total|pluralize }}<br>
{% endwith %}<br>
{{ person_list.2.name }}</p>
<p>{% with name=person_list.2.name %}<br>
{{ name }}</p>
<p>{% endwith %}<br>
内置过滤器<br>
{{ str|default:'返回值' }} ----&gt;&gt;&gt;&gt; 默认值<br>
{{ str|filesizeformat }} ----&gt;&gt;&gt;&gt; 将文件大小转换为 可读的 类型<br>
{{ str|add:'2' }} ----&gt;&gt;&gt;&gt; 给变量加参数 变量位数字 就加法运算 str 拼接<br>
{{ str|length }} ----&gt;&gt;&gt;&gt; 返回value 的长度<br>
{{ time|data:'Y-m-d H:i:s' }} ----&gt;&gt;&gt;&gt; 时间转换<br>
{{ time|data }} ----&gt;&gt;&gt;&gt; 时间转换 需在 stting 中配置<br>
{{ str|slice:'2:-1' }} ----&gt;&gt;&gt;&gt; 切片<br>
{{ list|first }} ----&gt;&gt;&gt;&gt; 取第一个<br>
{{ list|last }} ----&gt;&gt;&gt;&gt; 取最后一个<br>
{{ list|join:'//' }} ----&gt;&gt;&gt;&gt; 拼接<br>
{{ str|truncatechars:10 }} ----&gt;&gt;&gt;&gt; 截断字符串<br>
{{ html|safa }} ----&gt;&gt;&gt;&gt; 不转义 可写入 html 标签</p>
<p>自定义<br>
定义filter 过滤器<br>
在APP下创建一个叫templatetags的python包； 不能变的，必须是包，名字必须是templatetags<br>
在包中创建一个py文件 my_filters;<br>
在py文件中写代码<br>
from django import template</p>
<p>register = template.Library()  # register的名字不能改<br>
写函数<br>
@register.filter<br>
def add_dsb(value, arg):<br>
return &quot;{}<em>{}&quot;.format(value, arg)<br>
给定义的函数加装饰器<br>
@register.filter<br>
def add_dsb(value, arg):<br>
使用<br>
在模板中使用：<br>
导入定义的文件<br>
{% load my_filter %}<br>
使用过滤器<br>
{{ name|add_dsb:'very_dsb' }}<br>
定义simpletag<br>
和 定义 filter 一样<br>
@register.simple_tags<br>
def add_data(*args,**kwargs):<br>
return &quot;{}</em>{}&quot;.format(&quot;--&quot;.join(args),&quot;*&quot;.join(kwarg.values()))<br>
自定义inclusion_tag<br>
@register.inclusion_tag('show_li.html')<br>
def show_li(num):<br>
return {'num':range(1,num+1)}<br>
写模板 show_li.html</p>
<p>{% for i in num %}<br>
{{ i }}<br>
{% endfor %}</p>
<p>使用:<br>
模板中导入 {% load 定义的py文件名 %}<br>
filter {{ 变量|函数名：参数 }}<br>
simple_tag {{ 变量|函数名：参数 }}<br>
inclusion_tag {% inclusion_tag的函数名 %}<br>
标签<br>
{% csrf_token %}<br>
添加在form表单中 就可以提交POST请求<br>
母版和继承<br>
母版<br>
就是一个普通的HTML文本，将多个页面公共部分的内容提取出来，在页面中定义多个block块<br>
{% block content %}<br>
{% endblock %}<br>
继承<br>
在子页面中，继承母版 {% extends 'base.html' %}<br>
可以重新书写block块中内容<br>
注意事项<br>
{% extends 'base.html' %} 写在第一行，上面不写内容<br>
要修改的 内容写在block块中，写在外面不显示<br>
{% extends 'base.html' %} base.html 记得带上引号，不然当做变量去查找<br>
定义多个block块，一般要定义上 css和js<br>
组件include<br>
{% include 'nav.html' %}<br>
静态文件相关<br>
{% load static %}<br>
{% static '静态文件相对路径' %} ——》 获取到别名，跟后面的参数进行拼接<br>
{% get_static_prefix %} ——》 获取到别名</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python进程、线程、协程详解]]></title>
        <id>https://yooinn.github.io//post/python-jin-cheng-xian-cheng-xie-cheng-xiang-jie</id>
        <link href="https://yooinn.github.io//post/python-jin-cheng-xian-cheng-xie-cheng-xiang-jie">
        </link>
        <updated>2019-09-19T10:11:37.000Z</updated>
        <content type="html"><![CDATA[<p>进程与线程的历史<br>
我们都知道计算机是由硬件和软件组成的。硬件中的CPU是计算机的核心，它承担计算机的所有任务。 操作系统是运行在硬件之上的软件，是计算机的管理者，它负责资源的管理和分配、任务的调度。 程序是运行在系统上的具有某种功能的软件，比如说浏览器，音乐播放器等。 每次执行程序的时候，都会完成一定的功能，比如说浏览器帮我们打开网页，为了保证其独立性，就需要一个专门的管理和控制执行程序的数据结构——进程控制块。 进程就是一个程序在一个数据集上的一次动态执行过程。 进程一般由程序、数据集、进程控制块三部分组成。我们编写的程序用来描述进程要完成哪些功能以及如何完成；数据集则是程序在执行过程中所需要使用的资源；进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。</p>
<p>在早期的操作系统里，计算机只有一个核心，进程执行程序的最小单位，任务调度采用时间片轮转的抢占式方式进行进程调度。每个进程都有各自的一块独立的内存，保证进程彼此间的内存地址空间的隔离。 随着计算机技术的发展，进程出现了很多弊端，一是进程的创建、撤销和切换的开销比较大，二是由于对称多处理机（对称多处理机（SymmetricalMulti-Processing）又叫SMP，是指在一个计算机上汇集了一组处理器(多CPU)，各CPU之间共享内存子系统以及总线结构）的出现，可以满足多个运行单位，而多进程并行开销过大。 这个时候就引入了线程的概念。 线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合 和堆栈共同组成。线程的引入减小了程序并发执行时的开销，提高了操作系统的并发性能。 线程没有自己的系统资源，只拥有在运行时必不可少的资源。但线程可以与同属与同一进程的其他线程共享进程所拥有的其他资源。</p>
<p>进程与线程之间的关系<br>
线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)。</p>
<p><strong>python 线程</strong></p>
<p>Threading用于提供线程相关的操作，线程是应用程序中工作的最小单元。</p>
<p><strong>1、threading模块</strong><br>
threading 模块建立在 _thread 模块之上。thread 模块以低级、原始的方式来处理和控制线程，而 threading 模块通过对 thread 进行二次封装，提供了更方便的 api 来处理线程。</p>
<pre><code>
import threading
import time
   
def worker(num):
    &quot;&quot;&quot;
    thread worker function
    :return:
    &quot;&quot;&quot;
    time.sleep(1)
    print(&quot;The num is  %d&quot; % num)
    return
   
for i in range(20):
    t = threading.Thread(target=worker,args=(i,)，name=“t.%d” % i)
    t.start()
</code></pre>
<p>上述代码创建了20个“前台”线程，然后控制器就交给了CPU，CPU根据指定算法进行调度，分片执行指令。</p>
<p>Thread方法说明</p>
<p>t.start() : 激活线程，</p>
<p>t.getName() : 获取线程的名称</p>
<p>t.setName() ： 设置线程的名称</p>
<p>t.name : 获取或设置线程的名称</p>
<p>t.is_alive() ： 判断线程是否为激活状态</p>
<p>t.isAlive() ：判断线程是否为激活状态</p>
<p>t.setDaemon() 设置为后台线程或前台线程（默认：False）;通过一个布尔值设置线程是否为守护线程，必须在执行start()方法之后才可以使用。如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，均停止；如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止</p>
<p>t.isDaemon() ： 判断是否为守护线程</p>
<p>t.ident ：获取线程的标识符。线程标识符是一个非零整数，只有在调用了start()方法之后该属性才有效，否则它只返回None。</p>
<p>t.join() ：逐个执行每个线程，执行完毕后继续往下执行，该方法使得多线程变得无意义</p>
<p>t.run() ：线程被cpu调度后自动执行线程对象的run方法</p>
<p>2、线程锁threading.RLock和threading.Lock</p>
<p>由于线程之间是进行随机调度，并且每个线程可能只执行n条执行之后，CPU接着执行其他线程。为了保证数据的准确性，引入了锁的概念。所以，可能出现如下问题：</p>
<p>例：假设列表A的所有元素就为0，当一个线程从前向后打印列表的所有元素，另外一个线程则从后向前修改列表的元素为1,那么输出的时候，列表的元素就会一部分为0，一部分为1,这就导致了数据的不一致。锁的出现解决了这个问题。</p>
<pre><code>import threading
import time
   
globals_num = 0
   
lock = threading.RLock()
   
def Func():
    lock.acquire()  # 获得锁
    global globals_num
    globals_num += 1
    time.sleep(1)
    print(globals_num)
    lock.release()  # 释放锁
   
for i in range(10):
    t = threading.Thread(target=Func)
    t.start()
</code></pre>
<p><strong>3、threading.RLock和threading.Lock 的区别</strong><br>
RLock允许在同一线程中被多次acquire。而Lock却不允许这种情况。 如果使用RLock，那么acquire和release必须成对出现，即调用了n次acquire，必须调用n次的release才能真正释放所占用的琐。</p>
<pre><code>
import threading
lock = threading.Lock()    #Lock对象
lock.acquire()
lock.acquire()  #产生了死琐。
lock.release()
lock.release()　
import threading
rLock = threading.RLock()  #RLock对象
rLock.acquire()
rLock.acquire()    #在同一线程内，程序不会堵塞。
rLock.release()
rLock.release()
</code></pre>
<p><strong>4、threading.Event</strong></p>
<p>python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法 set、wait、clear。</p>
<p>事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。</p>
<p>clear：将“Flag”设置为False</p>
<p>set：将“Flag”设置为True</p>
<p>Event.isSet() ：判断标识位是否为Ture。</p>
<pre><code>import threading
   
def do(event):
    print('start')
    event.wait()
    print('execute')
   
event_obj = threading.Event()
for i in range(10):
    t = threading.Thread(target=do, args=(event_obj,))
    t.start()
   
event_obj.clear()
inp = input('input:')
if inp == 'true':
    event_obj.set()
</code></pre>
<p>当线程执行的时候，如果flag为False，则线程会阻塞，当flag为True的时候，线程不会阻塞。它提供了本地和远程的并发性。</p>
<p><strong>5、threading.Condition</strong></p>
<p>一个condition变量总是与某些类型的锁相联系，这个可以使用默认的情况或创建一个，当几个condition变量必须共享和同一个锁的时候，是很有用的。锁是conditon对象的一部分：没有必要分别跟踪。</p>
<p>condition变量服从上下文管理协议：with语句块封闭之前可以获取与锁的联系。 acquire() 和 release() 会调用与锁相关联的相应的方法。</p>
<p>其他和锁关联的方法必须被调用，wait()方法会释放锁，当另外一个线程使用 notify() or notify_all()唤醒它之前会一直阻塞。一旦被唤醒，wait()会重新获得锁并返回，</p>
<p>Condition类实现了一个conditon变量。 这个conditiaon变量允许一个或多个线程等待，直到他们被另一个线程通知。 如果lock参数，被给定一个非空的值，，那么他必须是一个lock或者Rlock对象，它用来做底层锁。否则，会创建一个新的Rlock对象，用来做底层锁。</p>
<p>wait(timeout=None) ： 等待通知，或者等到设定的超时时间。当调用这wait()方法时，如果调用它的线程没有得到锁，那么会抛出一个RuntimeError 异常。 wati()释放锁以后，在被调用相同条件的另一个进程用notify() or notify_all() 叫醒之前 会一直阻塞。wait() 还可以指定一个超时时间。</p>
<p>如果有等待的线程，notify()方法会唤醒一个在等待conditon变量的线程。notify_all() 则会唤醒所有在等待conditon变量的线程。</p>
<p>注意： notify()和notify_all()不会释放锁，也就是说，线程被唤醒后不会立刻返回他们的wait() 调用。除非线程调用notify()和notify_all()之后放弃了锁的所有权。</p>
<p>在典型的设计风格里，利用condition变量用锁去通许访问一些共享状态，线程在获取到它想得到的状态前，会反复调用wait()。修改状态的线程在他们状态改变时调用 notify() or notify_all()，用这种方式，线程会尽可能的获取到想要的一个等待者状态。 例子： 生产者-消费者模型，</p>
<pre><code>import threading
import time
def consumer(cond):
    with cond:
        print(&quot;consumer before wait&quot;)
        cond.wait()
        print(&quot;consumer after wait&quot;)
   
def producer(cond):
    with cond:
        print(&quot;producer before notifyAll&quot;)
        cond.notifyAll()
        print(&quot;producer after notifyAll&quot;)
   
condition = threading.Condition()
c1 = threading.Thread(name=&quot;c1&quot;, target=consumer, args=(condition,))
c2 = threading.Thread(name=&quot;c2&quot;, target=consumer, args=(condition,))
   
p = threading.Thread(name=&quot;p&quot;, target=producer, args=(condition,))
   
c1.start()
time.sleep(2)
c2.start()
time.sleep(2)
p.start()
</code></pre>
<p><strong>6、queue模块</strong></p>
<p>Queue 就是对队列，它是线程安全的</p>
<p>举例来说，我们去麦当劳吃饭。饭店里面有厨师职位，前台负责把厨房做好的饭卖给顾客，顾客则去前台领取做好的饭。这里的前台就相当于我们的队列。形成管道样，厨师做好饭通过前台传送给顾客，所谓单向队列</p>
<p>这个模型也叫生产者-消费者模型。</p>
<p>import queue</p>
<p>q = queue.Queue(maxsize=0)  # 构造一个先进显出队列，maxsize指定队列长度，为0 时，表示队列长度无限制。</p>
<p>q.join()    # 等到队列为kong的时候，在执行别的操作<br>
q.qsize()   # 返回队列的大小 （不可靠）<br>
q.empty()   # 当队列为空的时候，返回True 否则返回False （不可靠）<br>
q.full()    # 当队列满的时候，返回True，否则返回False （不可靠）<br>
q.put(item, block=True, timeout=None) #  将item放入Queue尾部，item必须存在，可以参数block默认为True,表示当队列满时，会等待队列给出可用位置，<br>
　　　　　　　　　　　　　　　　　　　　　　　　 为False时为非阻塞，此时如果队列已满，会引发queue.Full 异常。 可选参数timeout，表示 会阻塞设置的时间，过后，<br>
　　　　　　　　　　　　　　　　　　　　　　　　  如果队列无法给出放入item的位置，则引发 queue.Full 异常<br>
q.get(block=True, timeout=None) #   移除并返回队列头部的一个值，可选参数block默认为True，表示获取值的时候，如果队列为空，则阻塞，为False时，不阻塞，<br>
　　　　　　　　　　　　　　　　　　　　　　若此时队列为空，则引发 queue.Empty异常。 可选参数timeout，表示会阻塞设置的时候，过后，如果队列为空，则引发Empty异常。<br>
q.put_nowait(item) #   等效于 put(item,block=False)<br>
q.get_nowait() #    等效于 get(item,block=False)<br>
代码如下：</p>
<pre><code>
#!/usr/bin/env python
import Queue
import threading
message = Queue.Queue(10)
  
  
def producer(i):
    while True:
        message.put(i)
  
  
def consumer(i):
    while True:
        msg = message.get()
  
  
for i in range(12):
    t = threading.Thread(target=producer, args=(i,))
    t.start()
  
for i in range(10):
    t = threading.Thread(target=consumer, args=(i,))
    t.start()
那就自己做个线程池吧：

# 简单往队列中传输线程数
import threading
import time
import queue
class Threadingpool():
    def __init__(self,max_num = 10):
        self.queue = queue.Queue(max_num)
        for i in range(max_num):
            self.queue.put(threading.Thread)
    def getthreading(self):
        return self.queue.get()
    def addthreading(self):
        self.queue.put(threading.Thread)
def func(p,i):
    time.sleep(1)
    print(i)
    p.addthreading()
if __name__ == &quot;__main__&quot;:
    p = Threadingpool()
    for i in range(20):
        thread = p.getthreading()
        t = thread(target = func, args = (p,i))
        t.start()


#往队列中无限添加任务
import queue
import threading
import contextlib
import time
StopEvent = object()
class ThreadPool(object):
    def __init__(self, max_num):
        self.q = queue.Queue()
        self.max_num = max_num
        self.terminal = False
        self.generate_list = []
        self.free_list = []
    def run(self, func, args, callback=None):
        &quot;&quot;&quot;
        线程池执行一个任务
        :param func: 任务函数
        :param args: 任务函数所需参数
        :param callback: 任务执行失败或成功后执行的回调函数，回调函数有两个参数1、任务函数执行状态；2、任务函数返回值（默认为None，即：不执行回调函数）
        :return: 如果线程池已经终止，则返回True否则None
        &quot;&quot;&quot;
        if len(self.free_list) == 0 and len(self.generate_list) &lt; self.max_num:
            self.generate_thread()
        w = (func, args, callback,)
        self.q.put(w)
    def generate_thread(self):
        &quot;&quot;&quot;
        创建一个线程
        &quot;&quot;&quot;
        t = threading.Thread(target=self.call)
        t.start()
    def call(self):
        &quot;&quot;&quot;
        循环去获取任务函数并执行任务函数
        &quot;&quot;&quot;
        current_thread = threading.currentThread
        self.generate_list.append(current_thread)
        event = self.q.get()  # 获取线程
        while event != StopEvent:   # 判断获取的线程数不等于全局变量
            func, arguments, callback = event   # 拆分元祖，获得执行函数，参数，回调函数
            try:
                result = func(*arguments)   # 执行函数
                status = True
            except Exception as e:    # 函数执行失败
                status = False
                result = e
            if callback is not None:
                try:
                    callback(status, result)
                except Exception as e:
                    pass
            # self.free_list.append(current_thread)
            # event = self.q.get()
            # self.free_list.remove(current_thread)
            with self.work_state():
                event = self.q.get()
        else:
            self.generate_list.remove(current_thread)
    def close(self):
        &quot;&quot;&quot;
        关闭线程，给传输全局非元祖的变量来进行关闭
        :return:
        &quot;&quot;&quot;
        for i in range(len(self.generate_list)):
            self.q.put(StopEvent)
    def terminate(self):
        &quot;&quot;&quot;
        突然关闭线程
        :return:
        &quot;&quot;&quot;
        self.terminal = True
        while self.generate_list:
            self.q.put(StopEvent)
        self.q.empty()
    @contextlib.contextmanager
    def work_state(self):
        self.free_list.append(threading.currentThread)
        try:
            yield
        finally:
            self.free_list.remove(threading.currentThread)
def work(i):
    print(i)
    return i +1 # 返回给回调函数
def callback(ret):
    print(ret)
pool = ThreadPool(10)
for item in range(50):
    pool.run(func=work, args=(item,),callback=callback)
pool.terminate()
# pool.close()
</code></pre>
<p><strong>python 进程</strong><br>
multiprocessing是python的多进程管理包，和threading.Thread类似。</p>
<p><strong>1、multiprocessing模块</strong></p>
<p>直接从侧面用subprocesses替换线程使用GIL的方式，由于这一点，multiprocessing模块可以让程序员在给定的机器上充分的利用CPU。在multiprocessing中，通过创建Process对象生成进程，然后调用它的start()方法，</p>
<pre><code>
from multiprocessing import Process
  
def func(name):
    print('hello', name)
  
  
if __name__ == &quot;__main__&quot;:
    p = Process(target=func,args=('zhangyanlin',))
    p.start()
    p.join()  # 等待进程执行完毕
</code></pre>
<p>在使用并发设计的时候最好尽可能的避免共享数据，尤其是在使用多进程的时候。 如果你真有需要 要共享数据， multiprocessing提供了两种方式。</p>
<p>（1）multiprocessing，Array,Value</p>
<p>数据可以用Value或Array存储在一个共享内存地图里，如下：</p>
<pre><code>from multiprocessing import Array,Value,Process
  
def func(a,b):
    a.value = 3.333333333333333
    for i in range(len(b)):
        b[i] = -b[i]
  
  
if __name__ == &quot;__main__&quot;:
    num = Value('d',0.0)
    arr = Array('i',range(11))
  
  
    c = Process(target=func,args=(num,arr))
    d= Process(target=func,args=(num,arr))
    c.start()
    d.start()
    c.join()
    d.join()
  
    print(num.value)
    for i in arr:
        print(i)
</code></pre>
<p>输出：</p>
<p>3.1415927<br>
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]<br>
创建num和arr时，“d”和“i”参数由Array模块使用的typecodes创建：“d”表示一个双精度的浮点数，“i”表示一个有符号的整数，这些共享对象将被线程安全的处理。</p>
<p>Array(‘i’, range(10))中的‘i’参数：</p>
<p>‘c’: ctypes.c_char　　　　 ‘u’: ctypes.c_wchar　　　　‘b’: ctypes.c_byte　　　　 ‘B’: ctypes.c_ubyte</p>
<p>‘h’: ctypes.c_short　　　  ‘H’: ctypes.c_ushort　　  ‘i’: ctypes.c_int　　　　　 ‘I’: ctypes.c_uint</p>
<p>‘l’: ctypes.c_long,　　　　‘L’: ctypes.c_ulong　　　　‘f’: ctypes.c_float　　　　‘d’: ctypes.c_double</p>
<p><strong>（2）multiprocessing，Manager</strong></p>
<p>由Manager()返回的manager提供list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array类型的支持。</p>
<pre><code>
from multiprocessing import Process,Manager
def f(d,l):
    d[&quot;name&quot;] = &quot;zhangyanlin&quot;
    d[&quot;age&quot;] = 18
    d[&quot;Job&quot;] = &quot;pythoner&quot;
    l.reverse()
  
if __name__ == &quot;__main__&quot;:
    with Manager() as man:
        d = man.dict()
        l = man.list(range(10))
  
        p = Process(target=f,args=(d,l))
        p.start()
        p.join()
  
        print(d)
        print(l)
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>{0.25: None, 1: '1', '2': 2}
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
Server process manager比 shared memory 更灵活，因为它可以支持任意的对象类型。另外，一个单独的manager可以通过进程在网络上不同的计算机之间共享，不过他比shared memory要慢。
</code></pre>
<p><strong>2、进程池（Using a pool of workers）</strong></p>
<p>Pool类描述了一个工作进程池，他有几种不同的方法让任务卸载工作进程。</p>
<p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。</p>
<p>我们可以用Pool类创建一个进程池， 展开提交的任务给进程池。 例：</p>
<pre><code>#apply
from  multiprocessing import Pool
import time
  
def f1(i):
    time.sleep(0.5)
    print(i)
    return i + 100
  
if __name__ == &quot;__main__&quot;:
    pool = Pool(5)
    for i in range(1,31):
        pool.apply(func=f1,args=(i,))
  
#apply_async
def f1(i):
    time.sleep(0.5)
    print(i)
    return i + 100
def f2(arg):
    print(arg)
  
if __name__ == &quot;__main__&quot;:
    pool = Pool(5)
    for i in range(1,31):
        pool.apply_async(func=f1,args=(i,),callback=f2)
    pool.close()
    pool.join()
</code></pre>
<p>一个进程池对象可以控制工作进程池的哪些工作可以被提交，它支持超时和回调的异步结果，有一个类似map的实现。</p>
<p>processes ：使用的工作进程的数量，如果processes是None那么使用 os.cpu_count()返回的数量。</p>
<p>initializer： 如果initializer是None，那么每一个工作进程在开始的时候会调用initializer(*initargs)。</p>
<p>maxtasksperchild：工作进程退出之前可以完成的任务数，完成后用一个心的工作进程来替代原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要Pool存在工作进程就会一直存活。</p>
<p>context: 用在制定工作进程启动时的上下文，一般使用 multiprocessing.Pool() 或者一个context对象的Pool()方法来创建一个池，两种方法都适当的设置了context</p>
<p>注意：Pool对象的方法只可以被创建pool的进程所调用。</p>
<pre><code>New in version 3.2: maxtasksperchild

New in version 3.4: context
</code></pre>
<p><strong>进程池的方法</strong><br>
apply(func[, args[, kwds]]) ：使用arg和kwds参数调用func函数，结果返回前会一直阻塞，由于这个原因，apply_async()更适合并发执行，另外，func函数仅被pool中的一个进程运行。</p>
<p>apply_async(func[, args[, kwds[, callback[, error_callback]]]]) ： apply()方法的一个变体，会返回一个结果对象。如果callback被指定，那么callback可以接收一个参数然后被调用，当结果准备好回调时会调用callback，调用失败时，则用error_callback替换callback。 Callbacks应被立即完成，否则处理结果的线程会被阻塞。</p>
<p>close() ： 阻止更多的任务提交到pool，待任务完成后，工作进程会退出。</p>
<p>terminate() ： 不管任务是否完成，立即停止工作进程。在对pool对象进程垃圾回收的时候，会立即调用terminate()。</p>
<p>join() : wait工作线程的退出，在调用join()前，必须调用close() or terminate()。这样是因为被终止的进程需要被父进程调用wait（join等价与wait），否则进程会成为僵尸进程。</p>
<pre><code>
map(func, iterable[, chunksize])¶

map_async(func, iterable[, chunksize[, callback[, error_callback]]])¶

imap(func, iterable[, chunksize])¶

imap_unordered(func, iterable[, chunksize])

starmap(func, iterable[, chunksize])¶

starmap_async(func, iterable[, chunksize[, callback[, error_back]]])
</code></pre>
<p><strong>python 协程</strong></p>
<p>线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员。</p>
<p>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。</p>
<p>协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程；</p>
<p>event loop是协程执行的控制点， 如果你希望执行协程， 就需要用到它们。</p>
<p><strong>event loop提供了如下的特性：</strong></p>
<p>注册、执行、取消延时调用(异步函数)</p>
<p>创建用于通信的client和server协议(工具)</p>
<p>创建和别的程序通信的子进程和协议(工具)</p>
<p>把函数调用送入线程池中</p>
<p><strong>协程示例：</strong></p>
<pre><code>import asyncio
   
async def cor1():
    print(&quot;COR1 start&quot;)
    await cor2()
    print(&quot;COR1 end&quot;)
   
async def cor2():
    print(&quot;COR2&quot;)
   
loop = asyncio.get_event_loop()
loop.run_until_complete(cor1())
loop.close()
</code></pre>
<p>最后三行是重点。</p>
<p>asyncio.get_event_loop()  : asyncio启动默认的event loop</p>
<p>run_until_complete()  :  这个函数是阻塞执行的，知道所有的异步函数执行完成，</p>
<p>close()  :  关闭event loop。</p>
<p><strong>1、greenlet</strong></p>
<pre><code>import greenlet
def fun1():
    print(&quot;12&quot;)
    gr2.switch()
    print(&quot;56&quot;)
    gr2.switch()
  
def fun2():
    print(&quot;34&quot;)
    gr1.switch()
    print(&quot;78&quot;)
  
  
gr1 = greenlet.greenlet(fun1)
gr2 = greenlet.greenlet(fun2)
gr1.switch()
</code></pre>
<p><strong>2、gevent</strong></p>
<p><strong>gevent属于第三方模块需要下载安装包</strong></p>
<pre><code>pip3 install --upgrade pip3
pip3 install gevent


import gevent
  
def fun1():
    print(&quot;www.baidu.com&quot;)   # 第一步
    gevent.sleep(0)
    print(&quot;end the baidu.com&quot;)  # 第三步
  
def fun2():
    print(&quot;www.zhihu.com&quot;)   # 第二步
    gevent.sleep(0)
    print(&quot;end th zhihu.com&quot;)  # 第四步
  
gevent.joinall([
    gevent.spawn(fun1),
    gevent.spawn(fun2),
])
</code></pre>
<p><strong>遇到IO操作自动切换：</strong></p>
<pre><code>import gevent
import requests
def func(url):
    print(&quot;get: %s&quot;%url)
    gevent.sleep(0)
    date =requests.get(url)
    ret = date.text
    print(url,len(ret))
gevent.joinall([
    gevent.spawn(func, 'https://www.pythontab.com/'),
    gevent.spawn(func, 'https://www.yahoo.com/'),
    gevent.spawn(func, 'https://github.com/'),
])
</code></pre>
]]></content>
    </entry>
</feed>