<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yooinn.github.io/</id>
    <title>Jiank</title>
    <updated>2019-10-12T11:37:23.121Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yooinn.github.io/"/>
    <link rel="self" href="https://yooinn.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://yooinn.github.io//images/avatar.png</logo>
    <icon>https://yooinn.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Jiank</rights>
    <entry>
        <title type="html"><![CDATA[MongoDB的基本操作之索引]]></title>
        <id>https://yooinn.github.io//post/mongodb-de-ji-ben-cao-zuo-zhi-suo-yin</id>
        <link href="https://yooinn.github.io//post/mongodb-de-ji-ben-cao-zuo-zhi-suo-yin">
        </link>
        <updated>2019-10-12T11:24:18.000Z</updated>
        <content type="html"><![CDATA[<p>（一）索引的种类</p>
<p><em>_id 索引<br>
单键索引<br>
多键索引<br>
复合索引<br>
过期索引<br>
全文索引</em><br>
地理位置索引<br>
（二）查询索引</p>
<p>1、查询集合中所有索引<br>
db.imooc_collection.getIndexes()</p>
<p>（三）索引属性</p>
<p>1、创建索引时的格式：db.collection.ensureIndex({param},{param}),第2个参数便是对应的属性。</p>
<p>2、比较重要的属性：</p>
<p>（1）名字，name指定：</p>
<p>db.collection.ensureIndex({},{name;” “})</p>
<p>一旦我们自定义 name 之后，我们在删除索引是，可将自定义 name 作为参数<br>
db.collection.dropIndex(“name”)</p>
<p>（2）唯一性，unique指定，利用unique可以实现若存在，则不插入，若不存在则插入。</p>
<p>db.collection.ensureIndex({},{unique:true/false})</p>
<p>（3）稀疏性，sparse指定，不必为不存在的字段创建索引（默认不稀疏）</p>
<p>db.collection.ensureIndex({},{sparse:true/false})</p>
<pre><code>`#查找存在 m 字段的数据
db.imooc_2.find({m:{$exists:true}})

#建立 m 字段索引，且指定 稀疏性 true
db.imooc_2.ensureIndex({m:1},{sparse:true})

#查找非 m 字段的数据
db.imooc_2.find(m:{$exists:false})`
</code></pre>
<p>如果mongoDB在选取索引时，如果发现在稀疏索引上查找不存在文档，将不会使用稀疏索引，如果强制指定的话，就会发现问题。</p>
<p>④db.imooc_2.getIndexs()</p>
<p>⑤db.imooc_2.find({m:{$exists:false}}).hint(“m_1”)</p>
<p>不能在稀疏索引上查找字段不存在的记录。</p>
<p>（4）是否定时删除，expireAfterSeconds指定：TTL，过期索引。</p>
<p>（四）创建索引</p>
<p>1、_id 索引<br>
自动创建，无需手动创建</p>
<p>2、单键索引<br>
db.imooc_collection.ensureIndex({x:1})</p>
<p>（1）ensureIndex创建索引，参数是json文档<br>
（2）key的值不再代表值，而是代表方向： x:1代表正向排序，x:-1代表逆向排序。<br>
（3）创建索引要消耗很长的时间，如果系统负载较重，且有很多已经存在的文档，则不能直接使用ensureIndex这个命令，需要在数据库创建之前就创建索引。<br>
（4）创建索引会对写入有一定的影响</p>
<p>3、多键索引<br>
db.imooc_collection.insert({x:[1,2,3,4,5]})<br>
解析：因为上面在创建单键索引时，就是在 x 上创建的，所以，当这里插入的数据为数组时，就自动变为了多键索引。</p>
<p>4、复合索引<br>
插入数据<br>
db.imooc_collection.insert({x:1,y:2,z:3})<br>
创建复合索引<br>
db.imooc_collection.ensureIndex({x:1,y:1})</p>
<p><strong>1代表正向排序 -1代表逆向排序</strong><br>
5、过期索引<br>
创建过期索引<br>
db.imooc_collection.ensureIndex({time:1}，{expireAfterSeconds:10})<br>
插入数据<br>
db.imooc_collection.insert({time:new Date()})</p>
<p>解析：{expireAfterSeconds:10} 过期时间 10s</p>
<pre><code>过期索引的限制：
1.存储在过期索引字段的值必须是指定的时间类型，必须是ISODate或者ISODate数组，不能使用时间戳，否则不能自动删除。
例如 &gt;db.imooc_collection.insert({time:1})，这种是不能被自动删除的
2.如果指定了ISODate数组，则按照最小的时间进行删除。
3.过期索引不能是复合索引。因为不能指定两个过期时间。
4.删除时间是不精确的。删除过程是由MongoDB的后台进程每60s跑一次的，而且删除也需要一定时间，所以存在误差。
</code></pre>
<p>6、全文索引</p>
<p>（1）创建全文索引</p>
<p>1、db.imooc_collection.ensuerIndex({key:“text”})<br>
为key字段建全文索引，text为参数。</p>
<p>2、db.imooc_collection.ensuerIndex({key_1:“text”,key_2:“text”})<br>
为key_1,key_2字段建全文索引，text为参数。</p>
<p>3、db.imooc_collection.ensuerIndex({&quot;$**&quot;:“text”})<br>
不指定字段，创建集合下所有信息的全文索引。</p>
<p>（2）使用全文索引查询<br>
注意：一个集合只能创建一个全文索引</p>
<pre><code>    #查询包含aa的内容的文档
    db.imooc_collection.find({$text:{$search:&quot;aa&quot;}})
    
     #（或查询）查询包含aa或bb或cc的内容的文档
    db.imooc_collection.find({$text:{$search:&quot;aa bb cc&quot;}})
    
    #（\ 与查询）查询包含aa、bb和cc的内容的文档
    db.imooc_collection.find({$text:{$search:&quot;\&quot;aa\&quot; \&quot;bb\&quot; \&quot;cc\&quot;&quot;}})
    
    # -为排除包含有cc内容的文档
    db.imooc_collection.find({$text:{$search:&quot;aa bb -cc&quot;}}) 
</code></pre>
<p><strong>（3）使用全文索引带权重查询</strong><br>
<code>参数{score:{$meta:“textScore”}}，用于标识相似度。</code></p>
<pre><code>#参数{score:{$meta:&quot;textScore&quot;}}，用于标识相似度。
db.imooc_collection.find({$text:{$search:&quot;aa bb&quot;}},{score:{$meta:&quot;textScore&quot;}})

#按相似度排序
db.imooc_2.find({$text:{$search:&quot;aa bb&quot;}},{score:{$meta:&quot;textScore&quot;}}).sort({score:{$meta:&quot;textScore&quot;}})
</code></pre>
<p>（4）缺陷</p>
<p>全局索引的限制：</p>
<p>每次查询，只能指定一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">询</mi></mrow><annotation encoding="application/x-tex">text查询
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">询</span></span></span></span>text查询不能出现在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>o</mi><mi>r</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">询</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">询</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">含</mi><mi mathvariant="normal">了</mi></mrow><annotation encoding="application/x-tex">nor查询中
查询中如果包含了</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">询</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">询</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">含</span><span class="mord cjk_fallback">了</span></span></span></span>text, hint不再起作用<br>
7、地理位置索引</p>
<p>（1）2d索引<br>
db.collection.ensureIndex({“w”:“2d”})<br>
位置表示方式：经纬度【经度，维度】<br>
取值范围：经度【-180,180】纬度【-90,90】<br>
例如：db.collection.insert({w:[180,90]})</p>
<p>查询方式：<br>
1、$near查询：查询距离某个点最近的点,默认返回100个最近的点</p>
<pre><code>#查询距离点 [1,1] 最近的点
db.collection.find({w:{$near:[1,1]}})
#查询距离点 [1,1] 最近的点，且距离不超过10
db.collection.find({w:{$near:[1,1]，$maxDistance:10}})
</code></pre>
<p>2、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>e</mi><mi>o</mi><mi>W</mi><mi>i</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">询</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">询</mi><mi mathvariant="normal">某</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">形</mi><mi mathvariant="normal">状</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">形</mi><mi mathvariant="normal">状</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">示</mi><mi>a</mi><mi mathvariant="normal">、</mi></mrow><annotation encoding="application/x-tex">geoWithin查询：查询某个形状内的点
形状的表示
a、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">询</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">查</span><span class="mord cjk_fallback">询</span><span class="mord cjk_fallback">某</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">形</span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">形</span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">、</span></span></span></span>box:矩形，使用<br>
{<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 30: …&gt;],[&lt;x2&gt;,&lt;y2&gt;]]}̲//第一个坐标代表左边界，第二…'>box:[[&lt;x1&gt;,&lt;y1&gt;],[&lt;x2&gt;,&lt;y2&gt;]]}//第一个坐标代表左边界，第二个右边界
案例：db.location.find({w:{</span>geoWithin:{<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 18: …x:[[0,0],[3,3]]}̲}})
b、'>box:[[0,0],[3,3]]}}})
b、</span>center:圆形<br>
{<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 23: …[[&lt;x1&gt;,&lt;y1&gt;],r]}̲//r为圆的半径
案例：db.…'>center:[[&lt;x1&gt;,&lt;y1&gt;],r]}//r为圆的半径
案例：db.location.find({w:{</span>geoWithin:{<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 17: …enter:[[0,0],3]}̲}})
c、'>center:[[0,0],3]}}})
c、</span>polygon:多边形<br>
{<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 46: …&gt;],[&lt;x3&gt;,&lt;y3&gt;]]}̲
案例：db.location…'>polygon:[[&lt;x1&gt;,&lt;y1&gt;],[&lt;x2&gt;,&lt;y2&gt;],[&lt;x3&gt;,&lt;y3&gt;]]}
案例：db.location.find({w:{</span>geoWithin:{$polygon:[[0,0],[0,1],[2,5]]}}})</p>
<p>3、geoNear 查询（可以看做是$near查询的进化版本）<br>
它不仅支持 minDistance，而且它的返回结果多了一些数据。<br>
使用runCommand命令进行使用：</p>
<pre><code>db.runCommand({
				getNear:&lt;collection&gt;,	//指定数据集合
				near:[x,y],				//查询坐标
				minDistance:			(对2d索引无效，对2dsphere有效)
				maxDistance:			//返回符合文档最多的数量
				num:2				//返回的数量
			})
4、查询返回结果
{
&quot;results&quot;:[		//查询的结果
{
&quot;dis&quot;:	//查找到的数据与所指定查找的数据之间的距离
&quot;obj&quot;:{}	//查找到的数据
}
],
&quot;stats&quot;:{	//查询的参数
&quot;nscanned&quot;:	//扫描了哪些数据
&quot;objectsloaded&quot;:
&quot;avgDistance&quot;:		//平均距离
&quot;maxDistance&quot;:	//最大的距离
&quot;time&quot;:		//花费的时间
},
&quot;ok&quot;:
}
</code></pre>
<p>`（2）2dsphere 索引<br>
创建方法:db.collection.ensureindex({w: “2dsphere”})<br>
2Dsphere位置表示方式：<br>
GeoJSON：描述一个点，一条直线，多边形等形状。<br>
格式：<br>
{type:’’, coordinates:[list]}<br>
GeoJSON查询可支持多边形交叉点等，支持MaxDistance 和 MinDistance</p>
<p>（五）索引构建情况分析</p>
<p>1、使用索引的优缺点：<br>
优点，加快索引相关的查询<br>
缺点，增加磁盘空间的消耗，降低写入性能</p>
<p>2、判断当前索引构建的情况：</p>
<p>Mongostat工具<br>
profile集合<br>
日志<br>
explain<br>
3、Mongostat工具<br>
使用 mongostat 工具：./mongostat -h 127.0.0.1:27017</p>
<p>mongostat 输出部分字段的含义：<br>
（1）inserts/query/update/delete: 分别指当前mongodb插入、查询、更新、删除 数量，以每秒计；<br>
（2）getmore: MongoDB返回结果时，每次只会返回一定量；当我们继续用find()查询更多数据时，系统就会自动用getmore来获取之后的数据；<br>
（3）command: 执行的命令数量；<br>
（4）flushes: MongoDB使用虚拟内存映射的方式管理数据，我们在向MongoDB写入或查询数据时，MongoDB会做一次虚拟内存映射，有些数据其实是在硬盘上的；每隔一段时间，MongoDB会把我们写到内存的数据flush到硬盘上；这个数据大的话，会导致mongodb的性能较差；<br>
（5）mapped/vsize/res: 与磁盘空间大小有关，申请的内存大小；<br>
（6）faults：如果我们查询的数据，没有提前被MongoDB加载到内存中，我们就必须到硬盘上读取，叫做“换页”；如果faults比较高，也会造成性能下降；<br>
（7）idx miss: 表示我们的查询没有命中索引的比率；如果很高，说明索引构建有问题，索引不合适或者索引数量不够；<br>
（8）qr|qw: 说明MongoDB的写队列或者读队列的情况。我们向MongoDB读写时，这些请求会被放到队列中等待。数量大（几百上千）说明MongoDB处理速度慢或者读写请求太多，性能会下降。<br>
（9）ar|aw: 当前活跃的读写客户端的个数。</p>
<p>4、profile集合<br>
`</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mongo数据库]]></title>
        <id>https://yooinn.github.io//post/mongo-shu-ju-ku</id>
        <link href="https://yooinn.github.io//post/mongo-shu-ju-ku">
        </link>
        <updated>2019-10-10T13:20:24.000Z</updated>
        <content type="html"><![CDATA[<p><strong>mongo入门命令</strong></p>
<pre><code>show dbs  查看当前的数据库
 use databaseName 选库
show collections 查看当前库下的collection

</code></pre>
<p>如何创建库?<br>
Mongodb的库是隐式创建,你可以use 一个不存在的库，然后在该库下创建collection,即可创建库<br>
db.createCollection(‘collectionName’)<br>
即可创建一个集合。<br>
其实在MongoDB中，collection也是可以隐身创建的<br>
db.collectionName.insert(document)<br>
如何删除数据库和集合？<br>
db.collectionName.drop()//删除集合<br>
db.dropDatabase()//删除数据库</p>
<p>MongoDB基础增删改查操作</p>
<pre><code>1、增：insert方法
首先要明确一点，MongoDB存储的时文档，文档其实就是json格式的对象。
语法：
db.collectionName.isnert(document)
增加单篇文档：
db.collectionName.insert({title:’nice day’})
增加单个文档,并指定_id
db.collectionName.insert({_id:8,age:78,name:’lisi’})
增加多个文档
db.collectionName.insert(
[
{time:'friday',study:'mongodb'},
{_id:9,gender:'male',name:'QQ'}
]
)
2、删除：remove
语法:
 db.collection.remove(查询表达式, 选项)
选项是指  {justOne:true/false},是否只删一行, 默认为false
注意：
1: 查询表达式依然是个json对象 {age:20} where age =20   where age&gt;20
2: 查询表达式匹配的行,将被删掉.
3: 如果不写查询表达式,collections中的所有文档将被删掉
例1:删除stu表中 sn属性值为’001’的文档
 db.stu.remove({sn:’001’})
例2: 删除stu表中gender属性为m的文档,只删除1行.
db.stu.remove({gender:’m’,true});

3、更新：update
语法: db.collection.update(查询表达式,新值,选项)

改谁? --- 查询表达式
改成什么样? -- 新值 或 赋值表达式
操作选项 ----- 可选参数
例:
db.news.update({name:'QQ'},{name:'MSN'});
是指选中news表中,name值为QQ的文档,并把其文档值改为{name:’MSN’},结果: 文档中的其他列也不见了,改后只有_id和name列了，即--新文档直接替换了旧文档,而不是修改
如果是想修改文档的某列,可以用$set关键字：
db.collectionName.update(query,{$set:{name:’QQ’}})
修改时的赋值表达式
$set 修改某列的值
$unset 删除某个列
$rename 重命名某个列
$inc 增长某个列
Option的作用:{upsert:true/false,multi:true/false}
Upsert---是指没有匹配的行,则直接插入该行.
例:
db.stu.update({name:'wuyong'},{$set:{name:'junshiwuyong'}},{upsert:true});
如果有name=’wuyong’的文档,将被修改，如果没有,将添加此新文档
db.news.update({_id:99},{x:123,y:234},{upsert:true});
没有_id=99的文档被修改,因此直接插入该文档
multi: 是指修改多行(即使查询表达式命中多行,默认也只改1行,如果想改多行,可以用此选项)
db.news.update({age:21},{$set:{age:22}},{multi:true});
    则把news中所有age=21的文档,都修改
4、查: find
语法: db.collection.find(查询表达式,查询的列);
db.collections.find(表达式,{列1:1,列2:1});
    在查询的列参数中，1表示显示，0表示不显示
例1:db.stu.find()
    查询所有文档 所有内容
例2: db.stu.find({},{gendre:1})
    查询所有文档,的gender属性 (_id属性默认总是查出来)
例3: db.stu.find({},{gender:1, _id:0})
    查询所有文档的gender属性,且不查询_id属性
例4: db.stu.find({gender:’male’},{name:1,_id:0});
    查询所有gender属性值为male的文档中的name属性
    2. MongoDB AND 条件
    MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，及常规 SQL 的 AND 条件。类似于 WHERE 语句：WHERE by='优就业' AND title='MongoDB 教程。
    语法格式如下：
db.col.find({key1:value1， key2:value2}).pretty()
    3、常用方法：
limit()
db.COLLECTION_NAME.find().limit(NUMBER)
skip()
db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)
sort()
db.COLLECTION_NAME.find().sort({KEY:1})
count()
 db.mycol.count()
5、查询表达式:
最简单的查询表达式
| Model| 命令| Model | 命令|
| --------- | -------- | -----: | --: |
|  $lt| 小于  |  $lte |   小于等于 |
| $gt| 大于|   $gte|   大于等于 |
| $ne --- != | 查询表达式 
|  |     |    |    |


    {filed:value} ,是指查询field列的值为value的文档
$lt小于
$lte小于等于
$gt 大于
$gte大于等于
$ne --- != 查询表达式
{field:{$nq:value}} ---作用：查filed列的值 不等于 value 的文档
db.goods.find({cat_id:{$nq:3}},{cat_id:1,goods_id:1,goods_name:1,_id:0})
//查询cat_id不等3的数据
$nin --&gt; not in
db.stu.find({age:{$nin:[1,16]}})
$all：指数组所有单元匹配，就是指我指定的内容都要有，通过一个list来指定
db.stu.insert({name:'xt',age:99,hobby:['aa','bb']})
db.stu.find({hobby:{$all:['aa','bb']}},{name:1,age:1,_id:0})
$exists
        语法: {field:{$exists:1}}
        作用: 查询出含有field字段的文档
 db.stu.find({hobby:{$exists:1}})
$nor
{$nor,[条件1,条件2]} 是指  所有条件都不满足的文档为真返回
$and
        {$and,[条件1,条件2]} 是指  所有条件都满足，就为真
$or
        {$or,[条件1,条件2]} 是指  条件1和条件2有一个满足，就为真
</code></pre>
<p><strong>例子:</strong></p>
<h1 id="取出不属于第3栏目且不属于第11栏目的商品and-nin和nor分别实现">//取出不属于第3栏目且不属于第11栏目的商品($and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">nin和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">和</span></span></span></span>nor分别实现)</h1>
<p>db.goods.find({<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …:[{shop_price:{'>and:[{shop_price:{</span>lt:500}},{shop_price:{<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 7: gt:100}̲}]},{_id:0,shop…'>gt:100}}]},{_id:0,shop_price:1})
db.goods.find({</span>nor:[{cat_id:3},{cat_id:11}]},{cat_id:1})<br>
db.goods.find({cat_id:{$nin:[3,11]}},{cat_id:1})</p>
<h1 id="取出价格大于100且小于300或者大于4000且小于5000的商品">//取出价格大于100且小于300,或者大于4000且小于5000的商品()</h1>
<p>db.goods.find({<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: or:[{'>or:[{</span>and:[{shop_price:{<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 7: gt:100}̲},{shop_price:{'>gt:100}},{shop_price:{</span>lt:300}}]},{<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …:[{shop_price:{'>and:[{shop_price:{</span>gt:4000}},{shop_price:{$lt:5000}}]}]})</p>
<h1 id="取出goods_id5-1-即1611这样的商品">取出goods_id%5 == 1, 即,1,6,11,..这样的商品</h1>
<p>db.goods.find({goods_id:{$mod:[5,1]}},{goods_id:1})</p>
<p>格式db.表明.find({表内容:值|条件})</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 爬虫框架scrapy笔记]]></title>
        <id>https://yooinn.github.io//post/python-pa-chong-kuang-jia-scrapy-bi-ji</id>
        <link href="https://yooinn.github.io//post/python-pa-chong-kuang-jia-scrapy-bi-ji">
        </link>
        <updated>2019-10-10T00:49:21.000Z</updated>
        <content type="html"><![CDATA[<pre><code>scrapy startproject name 创建项目
scrapy genspider spider_name 创建爬虫文件
编写代码
scrapy crawl spider_name 运行爬虫
</code></pre>
<pre><code>项目文件下所有py的功能介绍：
scrapy.cfg：配置文件
spiders：存放你Spider文件，也就是你爬取的py文件
items.py：相当于一个容器，和字典较像
middlewares.py：定义Downloader Middlewares(下载器中间件)和Spider Middlewares(蜘蛛中间件)的实现
pipelines.py:定义Item Pipeline的实现，实现数据的清洗，储存，验证。
settings.py：全局配置
</code></pre>
<p><strong>一个例子</strong></p>
<pre><code>boss直聘项目：
1.创建项目
scrapy startproject name 创建项目
2.创建spider
scrapy genspider spider_name 创建爬虫文件
3.robots改为false
项目里settings.py里面
	COOKIES_ENABLED = False
4.设置请求头
	DEFAULT_REQUEST_HEADERS = {
5.添加待爬取的url到start_urks
6、测试parse方法能否爬取到页面数据。如果不能分析。
	这个项目需要添加cookie，如果想要设置自定义的cookie，需要将：
	COOKIES_ENABLED = False
7、爬取数据：
	1、在items.py中定义爬取字段
	2.在parse方法中实例化items
	item = BosszpItem()
	3、提取item的每个字段，并设置到item中。
	item['name'] = name
	item['salary'] = salary
	4、设置好之后，yield item，开始编写pipeline的内容
	5、写好pipeline之后，需要配置才能生效。
	
中间件如何设置：
	1.新建一个文件，比如：mymidderware.py
	2.在这个类中，主要实现：
	    def process_request(self, request, spider):
        if spider.name=='tencent':
            print('============in middle============')
            self.driver.get(request.url)
            self.wait.until(EC.presence_of_element_located((By.XPATH,'//div[@class=&quot;search-content&quot;]')))
            html = self.driver.page_source
            #将页面内容包装到一个response对象中
            return HtmlResponse(request.url,body=html,encoding='utf-8',request=request)
        print('====222======')
        return None
	3.配置：
	DOWNLOADER_MIDDLEWARES = {
   'bosszp.MyMiddleWares.MiddleWares_Tencent': 543,
	}

LOG_ENABLED=True
LOG_ENCODING='utf-8'
LOG_FILE='tencent.log'
LOG_LEVEL = 'INFO'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python中MD5加密]]></title>
        <id>https://yooinn.github.io//post/python-zhong-md5-jia-mi</id>
        <link href="https://yooinn.github.io//post/python-zhong-md5-jia-mi">
        </link>
        <updated>2019-09-27T01:22:05.000Z</updated>
        <content type="html"><![CDATA[<p>Python中生成MD5</p>
<h1 id="由于md5模块在python3中被移除">由于MD5模块在python3中被移除</h1>
<h1 id="在python3中使用hashlib模块进行md5操作">在python3中使用hashlib模块进行md5操作</h1>
<pre><code>import hashlib

# 待加密信息
str = '123456'
# 创建md5对象
hl = hashlib.md5()
#更新hash对象的值，如果不使用update方法也可以直接md5构造函数内填写
#md5_obj=hashlib.md5(&quot;123456&quot;.encode(&quot;utf-8&quot;)) 效果一样
hl.update(str.encode(&quot;utf-8&quot;))
print('MD5加密前为 ：' + str)
print('MD5加密后为 ：' + hl.hexdigest())
</code></pre>
<p><strong>MD5双重加密</strong></p>
<pre><code>md5_obj=hashlib.md5(&quot;123456&quot;.encode(&quot;utf-8&quot;))
str1=md5_obj.hexdigest() #加密1次
obj2=hashlib.md5(str1.encode(&quot;utf-8&quot;))
str2=obj2.hexdigest()#加密2次
print(str2) #双重加密后，同样解密开
</code></pre>
<p><strong>MD5加盐值(SALT)</strong></p>
<pre><code>from random import Random  
import hashlib
  
# 获取由4位随机大小写字母、数字组成的salt值  
def create_salt(length = 4):  
    salt = ''  
    chars = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789'  
    len_chars = len(chars) - 1  
    random = Random()  
    for i in range(length):  
        # 每次从chars中随机取一位  
        salt += chars[random.randint(0, len_chars)]  
    return salt  
  
# 获取原始密码+salt的md5值  
def create_md5(pwd,salt):  
    md5_obj = hashlib.md5()  
    md5_obj.update((pwd + salt).encode(&quot;utf-8&quot;))  
    return md5_obj.hexdigest()  
  
# 原始密码  
pwd = '123456'  
# 随机生成4位salt  
salt = create_salt()  
# 加密后的密码  
md5 = create_md5(pwd, salt)  
  
print('[pwd]\n',pwd ) 
print('[salt]\n', salt)  
print('[md5]\n', md5) 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS下编译安装Python3教程]]></title>
        <id>https://yooinn.github.io//post/centos-xia-bian-yi-an-zhuang-python3-jiao-cheng</id>
        <link href="https://yooinn.github.io//post/centos-xia-bian-yi-an-zhuang-python3-jiao-cheng">
        </link>
        <updated>2019-09-20T13:35:12.000Z</updated>
        <content type="html"><![CDATA[<p>到官网获取最新版的Python3 下载地址 https://www.python.org/downloads/source/ ， 现在最新版是Python3.7.2</p>
<p>下载完成后，解压,执行命令：</p>
<pre><code>
[www@pythontab.com]$ wget --no-check-certificate https://www.python.org/ftp/python/3.7.2/Python-3.7.2.tgz
[www@pythontab.com]$ xz -d Python-3.7.2.tgz
[www@pythontab.com]$ tar -xzvf Python-3.7.2.tgz
2. 编译前配置
[www@pythontab.com]$ cd Python-3.7.2/
[www@pythontab.com]$ ./configure --prefix=/usr/local/python3.7 --enable-optimizations
</code></pre>
<p>上面的命令解释一下：</p>
<p>--prefix 选项是配置安装的路径，如果不配置该选项，安装后可执行文件默认放在/usr/local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr/local/share。</p>
<p>如果配置--prefix，如：./configure --prefix=/usr/local/python3.7可以把所有资源文件放在/usr/local/python3.7的路径中，便于管理。</p>
<p>--enable-optimizations 是优化选项（LTO,PGO 等）加上这个 flag 编译后，性能有 10% 左右的优化,但是这会明显的增加编译时间。</p>
<p>./configure命令执行完毕之后创建一个文件 Makefile, 供下面的make命令使用,执行make install之后就会把程序安装到我们指定的文件夹中去。</p>
<ol start="3">
<li>执行编译和安装</li>
</ol>
<pre><code>[www@pythontab.com]$ make &amp;&amp; make install
安装完成之后进入到/usr/local/python3.7目录,可以看到Python的可执行文件目录bin等相关目录了。
</code></pre>
<ol start="4">
<li>增加软连接<br>
执行完上一步，你可能还不能直接运行Python3命令，因为你的/usr/local/可能不在PATH环境变量中， 我们可以通过增加软连接的方式来解决这个问题</li>
</ol>
<p>执行如下命令：</p>
<pre><code>
[www@pythontab.com]$ ln -s /usr/local/python3.7/bin/python3.7 /usr/bin/python3
[www@pythontab.com]$ ln -s /usr/local/python3.7/bin/python3.7 /usr/bin/python3.7
这时候你再执行Python3或者Python3.7就可以运行了

[www@pythontab.com]$ python3
Python 3.7.2 (default, Mar  3 2019, 13:15:50) 
[GCC 4.4.7 20120313 (Red Hat 4.4.7-16)] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
</code></pre>
<blockquote>
<blockquote>
<blockquote></blockquote>
</blockquote>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django框架静态文件使用/中间件/禁用ip功能实例详解]]></title>
        <id>https://yooinn.github.io//post/django-kuang-jia-jing-tai-wen-jian-shi-yong-zhong-jian-jian-jin-yong-ip-gong-neng-shi-li-xiang-jie</id>
        <link href="https://yooinn.github.io//post/django-kuang-jia-jing-tai-wen-jian-shi-yong-zhong-jian-jian-jin-yong-ip-gong-neng-shi-li-xiang-jie">
        </link>
        <updated>2019-09-20T13:14:23.000Z</updated>
        <content type="html"><![CDATA[<p>静态文件</p>
<p>一、静态文件的使用</p>
<p>静态文件：网页中使用的css，js，图片</p>
<p>静态文件的使用：</p>
<p>在项目下创建静态目录，比如：static，导入静态文件（HTML、CSS、js）</p>
<p>在setting.py中配置静态目录</p>
<pre><code>
# 通过此url来引用静态文件，可以隐藏服务器的文件的实际保存目录
STATIC_URL = '/abc/'
# 指定静态文件所在的物理目录
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]
</code></pre>
<p>通过setting.py中的STATIC_URL的值来引用静态文件，好处：可以隐藏服务器的文件的实际保存目录。比如：</p>
<pre><code>&lt;img src=&quot;/abc/image/mm.jpg&quot; /&gt;
&lt;script src=&quot;/abc/js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>二、使用static标签动态引用</p>
<p>上述写法是硬编码，存在维护问题，可以使用static标签动态引用</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
{% load staticfiles %}
&lt;head&gt;
...
&lt;/head&gt;
&lt;body&gt;
动态引用：&lt;br/&gt;
&lt;img src=&quot;{% static 'image/mm.jpg' %}&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>中间件</p>
<p>MIDDLEWARE: 中间件</p>
<p>一、案例： 禁止指定ip地址的访问</p>
<p>使用request对象的META属性，可以获取用户访问的ip地址：</p>
<p>request.META.get('REMOTE_ADDR')</p>
<p>二、中间件</p>
<p>中间件： django框架预留的接口，可以控制请求和响应的过程。Django在中间件中预置了6个方法，这些方法会在不同的阶段执行，对输入或输出进行干预。</p>
<figure data-type="image" tabindex="1"><img src="https://files.jb51.net/file_images/article/201907/2019722114704117.png?2019622114834" alt=""></figure>
<p>初始化：无需任何参数，服务器响应第一个请求的时候调用一次：</p>
<p>def <strong>init</strong>():<br>
pass</p>
<p>处理请求前(url匹配前)调用： 返回None或HttpResponse对象</p>
<p>def process_request(self, request):<br>
pass</p>
<p>url匹配后视图函数处理前调用： 返回None或HttpResponse对象</p>
<p>def process_view(self, request, view_func, view_args, view_kwargs):<br>
pass</p>
<p>视图函数出异常时调用：返回一个HttpResponse对象</p>
<p>def process_exception(self, request, exception):<br>
return response</p>
<p>视图函数处理后，模板响应处理前调用： 返回实现了render方法的响应对象</p>
<p>def process_template_response(self, request, response):<br>
pass</p>
<p>视图函数返回TemplateReponse时才会调用，返回HttpResponse对象不会调用</p>
<p>视图函数处理后，返回内容给浏览器前调用：返回HttpResponse对象</p>
<p>def process_response(self, request, response):<br>
return response</p>
<p>禁用ip功能</p>
<p>在MyMiddleware的process_view方法中，新增代码如下：</p>
<p>class MyMiddleware(object):<br>
...<br>
exclude_ips = ['127.0.0.1']<br>
def process_view(self, request, view_func, view_args, view_kwargs):<br>
print('--process_view--')<br>
# 禁用ip，以下代码也可以添加到process_request方法<br>
ip = request.META.get('REMOTE_ADDR')<br>
if ip in exclude_ips:<br>
return HttpResponse('禁止访问')</p>
<p>异常处理</p>
<p>异常处理： 视图函数执行出错之后，会调用中间件的process_exception方法，可以在该方法中执行异常操作。</p>
<p>在index视图函数中，添加执行出错代码：</p>
<p>def index(request):<br>
&quot;&quot;&quot;进入首页&quot;&quot;&quot;<br>
print('=<mark><mark>index</mark></mark>')</p>
<h1 id="添加出错代码">添加出错代码</h1>
<p>aa = None<br>
print('aa='+ aa)<br>
return render(request, 'app01/index.html')</p>
<p>在前面编写的MyMiddleware中： 添加处理异常的中间件方法，并注释前面的拦截ip的拦截：</p>
<h1 id="middlewarepy">middleware.py</h1>
<p>class MyMiddleware(object):<br>
...<br>
def process_view(self, request, view_func, view_args, view_kwargs):<br>
print('-------process_view')<br>
# # 禁止ip访问<br>
# ip = request.META.get('REMOTE_ADDR')<br>
# if ip in exclude_ips:<br>
#   return HttpResponse('禁止访问')<br>
def process_exception(self, request, exception):<br>
print('-----process_exception')</p>
<p>访问首页，查看服务器，发现：处理异常的中间件方法process_exception执行了</p>
<p>处理出错： 在process_exception方法中返回HttpResponse对象就可以了：</p>
<h1 id="middlewarepy-2">middleware.py</h1>
<p>class MyMiddleware(object):<br>
...<br>
def process_exception(self, request, exception):<br>
print('-----process_exception')<br>
return HttpResponse('运行出错了：%s' % exception)</p>
<p>希望本文所述对大家基于Django框架的Python程序设计有所帮助。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django中间件拦截未登录url实例详解]]></title>
        <id>https://yooinn.github.io//post/django-zhong-jian-jian-lan-jie-wei-deng-lu-url-shi-li-xiang-jie</id>
        <link href="https://yooinn.github.io//post/django-zhong-jian-jian-lan-jie-wei-deng-lu-url-shi-li-xiang-jie">
        </link>
        <updated>2019-09-20T13:13:48.000Z</updated>
        <content type="html"><![CDATA[<p>1.利用装饰器在视图中拦截未登录的url</p>
<p>@login_required(login_url='/user/login/')<br>
def homepage(request):<br>
pass<br>
这种方法适合于程序中只有少数几个需要登录拦截的url。</p>
<ol start="2">
<li>利用中间件技术拦截未登录的url</li>
</ol>
<p>2.1 在settings.py添加MIDDLEWARE设置：middleware.LoginCheckMiddleware</p>
<p>MIDDLEWARE = [<br>
'django.middleware.security.SecurityMiddleware',<br>
'django.contrib.sessions.middleware.SessionMiddleware',<br>
'django.middleware.common.CommonMiddleware',</p>
<h1 id="djangomiddlewarecsrfcsrfviewmiddleware">'django.middleware.csrf.CsrfViewMiddleware',</h1>
<p>'django.contrib.auth.middleware.AuthenticationMiddleware',<br>
'django.contrib.messages.middleware.MessageMiddleware',<br>
'django.middleware.clickjacking.XFrameOptionsMiddleware',</p>
<h1 id="url登录拦截中间件">url登录拦截中间件</h1>
<p>'middleware.LoginCheckMiddleware',<br>
]<br>
2.2 在项目目录下创建middleware.py文件，文件中创建拦截类：LoginCheckMiddleware</p>
<p>import re<br>
from django.http import JsonResponse<br>
from django.shortcuts import HttpResponseRedirect<br>
from django.utils.deprecation import MiddlewareMixin</p>
<p>class LoginCheckMiddleware(MiddlewareMixin):<br>
def process_request(self, request):<br>
# | 分隔要匹配的多个url，从左到右匹配，有匹配就返回匹配值，否则返回None。<br>
pattern = r'^(/<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">/</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mo>[</mo><mn>0</mn><mo>−</mo><mn>9</mn><mo>]</mo><mo>+</mo><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">|/user/user/[0-9]+/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span></span></span></span>|/user/user/$|/user/getuserall|/user/get_token_code|/user/update_phone_no|/stock|/future)'</p>
<pre><code># 如果 request.path 的开始位置能够找到这个正则样式的任意个匹配，就返回一个相应的匹配对象。
# 如果不匹配，就返回None
match = re.search(pattern, request.path)
# 需要拦截的url
if match and not request.user.is_authenticated:
  print('用户未登录URL拦截 &gt;&gt;: ', request.path)
</code></pre>
<p># 主页未登录<br>
if request.path == '/':<br>
return HttpResponseRedirect('/user/login/')<br>
# ajax请求未登录<br>
else:<br>
return JsonResponse({'status': False, 'info': '用户未登录!'})<br>
应用了正则表达式过滤需要拦截的url。</p>
<p>由于ajax请求不能重定向，所以对于ajax请求的url拦截返回json数据，由前端处理返回的结果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python写一个基于MD5的文件监听程序]]></title>
        <id>https://yooinn.github.io//post/python-xie-yi-ge-ji-yu-md5-de-wen-jian-jian-ting-cheng-xu</id>
        <link href="https://yooinn.github.io//post/python-xie-yi-ge-ji-yu-md5-de-wen-jian-jian-ting-cheng-xu">
        </link>
        <updated>2019-09-20T12:28:41.000Z</updated>
        <content type="html"><![CDATA[<p>前述</p>
<p>写了一个基于MD5算法的文件监听程序，通过不同的文件能够生成不同的哈希函数，来实现实现判断文件夹中的文件的增加、修改、删除和过滤含有特定字符的文件名的文件。</p>
<p>需求说明<br>
需要实现对一个文件夹下的文件的增加、修改和删除的监控， 一旦发生上述操作，则进行提示。可以选择过滤掉文件名中的特定字符和只监听文件名中含有特定字符的文件。</p>
<p>简述<br>
首先，关于文件的增加、修改、删除的反馈，可以想到利用MD5等类似的加密算法，因为文件本身可以生成哈希值，只要文件内容或者文件名被修改过，就会生成和修改之前的哈希值不同的值，因此可以利用dict来存储，一个文件名对应一个哈希值来存储。其中增加和删除就对应一个新增加的键值对和一个减少的键值对，而修改则可以理解为删除了旧的文件、增加了一个新的文件。<br>
MD5算法可以直接利用第三方的 hashlib 库来实现</p>
<p>m = hashlib.md5()<br>
myFile = open(full_path, 'rb')<br>
for line in myFile.readlines(): #以行为单位不断更新哈希值，避免文件过大导致一次产生大量开销<br>
m.update(line) #最后可以得到整个文件的哈希值<br>
第二，关于滤掉文件名中的特定字符和只监听文件名中含有特定字符的文件的功能，这个其实非常简单，只需要用 list 分别对需要过滤和必须存在字符串进行存储， 然后利用标志位和字符串的子串包含性进行判断就可以了，只有满足条件的文件可以产生哈希值，产生哈希值也就意味着被监听了。<br>
判断字符串中是否含有字串最常用的方法是 in 和 string 中的 find 方法，这里就不再赘述，可以直接看下面的代码</p>
<p>第三，因为要同时监控多个文件夹，所以必须要利用到线程来处理，创建一个线程池来存储线程， 线程利用了 threading 库，并且实现一个线程类来处理线程的操作<br>
class myListener(threading.Thread):<br>
thread1 = myListener(mydir, json_list_include, json_list_exclude) #生成线程<br>
说明<br>
需要额外说明的一点是，在传输需要监听的文件夹、必须包含的字段以及过滤字段的时候，我这里是利用配置文件的形式来存储的。说到底，是利用 toml 格式的数据进行的传输，toml格式和 json格式相比，用户的可读性更强一些，为了便于博客展示，因此利用了 toml 格式</p>
<p>首先利用代码生成了一下toml格式的文件，以后再想用的话，程序打包之后，可以直接修改配置文件来实现对程序的控制。</p>
<p>#!/usr/bin/env python</p>
<h1 id="-codingutf-8-">-<em>- coding:utf-8 -</em>-</h1>
<h1 id="author-jyroooy">Author: JYRoooy</h1>
<p>import collections<br>
import json<br>
import toml<br>
if <strong>name</strong> == '<strong>main</strong>':<br>
myOrderDict = collections.OrderedDict<br>
myOrderDict = {'dict':[{'path':'E:/testing', 'include':['log_'], 'exclude': ['.swp', '.swx', 'tmp']},{'path':'E:/tmp', 'include':['.record'], 'exclude': ['.tmp']}]}<br>
myToml = toml.dump(myOrderDict, open('E:/python/code/PythonProject/tomlConfig.txt','w+'))<br>
toml文件</p>
<p>格式说明， 一个 dict 对应一个监听的文件夹和需要 过滤(exculde) 和 含有(include) 的字段，解释一下，这里的字段只是文件名的字段，监控 E:/testing 目录下的文件，要包含 log_ 字段的文件，且不包含 .swp .swx .tmp 字段的文件， 并且监控 E:/tmp 目录下的文件，要包含 .record 字段的文件，且不包含 .tmp 的文件。<br>
<img src="https://files.jb51.net/file_images/article/201903/2019311100740411.png?201921110747" alt=""><br>
代码<br>
完整程序的代码，具体解释可以看注释</p>
<pre><code>#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: JYRoooy
import toml
import hashlib
import os
import sys
import time
import importlib
import threading
importlib.reload(sys)

class myListener(threading.Thread):
 '''
 监听类
 '''
 def __init__(self, input_dir, filt_in, filt_ex): #文件夹路径，必须包含的字符，必须过滤的字符
 threading.Thread.__init__(self)
 self.input_dir = input_dir
 self.filt_in = filt_in
 self.filt_ex = filt_ex
 self.dict = {} #用来存储文件名和对应的哈希值
 self.file_list = [] #存储每一次扫描时的文件的文件名
 self.pop_list = [] #存储需要删除的文件名

 def run(self):
 while (1): #保证文件夹一直处于被监听的状态
  for cur_dir, dirs, files in os.walk(self.input_dir):
  if files != []:
   self.file_list = []
   for each_file_1 in files:
   each_file = each_file_1
   if self.filt_in: #判断文件名中是否有必须存在的字段
    flagone = 0
    for i in range(len(self.filt_in)):
    if self.filt_in[i] in each_file:
     flagone += 1
    if flagone == 0:
    continue

   if self.filt_ex: #判断文件名中是否有必须过滤掉的字段
    flagtwo = 0
    for i in range(len(self.filt_ex)):
    if self.filt_ex[i] in each_file:
     flagtwo = 1
    if flagtwo==1:
    continue

   self.file_list.append(each_file)
   full_path = os.path.join(cur_dir, each_file)
   m = hashlib.md5() #实例化md5算法

   myFile = open(full_path, 'rb')

   for line in myFile.readlines():
    m.update(line)
   if each_file not in self.dict.keys(): #如果当前的dict中没有这个文件，那么就添加进去
    self.dict[each_file] = m.hexdigest() #生成哈希值
    print('文件夹:' +cur_dir+ &quot;中的文件名为：&quot; + each_file + &quot;的文件为新文件&quot; + time.strftime('%Y-%m-%d %H:%M:%S',
           time.localtime(time.time())))
   if each_file in self.dict.keys() and self.dict[each_file] != m.hexdigest(): #如果当前dict中有这个文件，但是哈希值不同，说明文件被修改过，则需要对字典进行更新
    print('文件夹:' +cur_dir+ &quot;中的文件名为：&quot; + each_file + &quot;的文件被修改于&quot; + time.strftime('%Y-%m-%d %H:%M:%S',
           time.localtime(time.time())))
    self.dict[each_file] = m.hexdigest()
   myFile.close()
  pop_list = []
  for i in self.dict.keys():
   if i not in self.file_list: #当字典中有不在当前文件名列表中时，说明文件已经被删除
   print('文件夹:' +cur_dir+ '中的文件名为:' + i + &quot;的文件已被删除!!!&quot; + time.strftime('%Y-%m-%d %H:%M:%S',
          time.localtime(time.time())))
   pop_list.append(i)
  for i in pop_list:
   self.dict.pop(i)

  time.sleep(2)

if __name__ == '__main__':
 threads = [] #用来存储线程的线程池
 with open('E:/python/code/PythonProject/tomlConfig.txt','r+') as f: #读取toml格式的文件，并分解格式
 mytoml = toml.load(f)
 myList = mytoml['dict']
 for i in range(len(myList)): #因为可能同时需要监听多个文件夹，所以利用线程池处理多线程
  json_list_include = []
  json_list_exclude = []
  mydir = myList[i]['path']
  for sublist in range(len(myList[i]['include'])):
  json_list_include.append(myList[i]['include'][sublist])
  for sublist in range(len(myList[i]['exclude'])):
  json_list_exclude.append(myList[i]['exclude'][sublist])
  thread1 = myListener(mydir, json_list_include, json_list_exclude) #生成线程
  threads.append(thread1)

 for t in threads: #开启所有线程
  t.start();
</code></pre>
<p>运行结果<br>
两个文件夹中的文件<br>
<img src="https://files.jb51.net/file_images/article/201903/2019311100842641.png?201921110849" alt=""><br>
第一次运行程序， 可以看到已经按照过滤规则完成了过滤和监听<br>
<img src="https://files.jb51.net/file_images/article/201903/2019311100945510.png?201921110951" alt=""><br>
修改 loko.record 文件为 loko.re，再来看结果<br>
<img src="https://files.jb51.net/file_images/article/201903/2019311101001277.png?201921110107" alt=""></p>
<p>可以看到已经完成了监听，因为 loko.re 文件，并符合监听的规则，所以不做出监听，而我们前面说过，一个修改相当于一个删除和一个新建操作，所以监听程序提示原文件被删除了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django-simple-captcha 图形验证码模块]]></title>
        <id>https://yooinn.github.io//post/django-simple-captcha-tu-xing-yan-zheng-ma-mo-kuai</id>
        <link href="https://yooinn.github.io//post/django-simple-captcha-tu-xing-yan-zheng-ma-mo-kuai">
        </link>
        <updated>2019-09-20T06:56:49.000Z</updated>
        <content type="html"><![CDATA[<p>**一、引言 **<br>
        官方文档：django-simple-captcha</p>
<p>本博客谈不上深度，算是笔记和一些探索经验。主要是遇到了一个实际问题，在使用django-simple-captcha模块的时候，官网推荐使用django表单的形式去添加，django表单确实很方便，但是对于简单项目或者只需要django-simple-captcha模块的时候也没有太多的文档具体说明，这篇博客就说一下怎么单独使用django-simple-captcha模块。</p>
<p>目标：实现手动创建验证码和前端显示，后台手动验证，ajax请求。</p>
<p><strong>二、流程</strong><br>
1）安装 django-simple-captcha</p>
<p>pip install django-simple-captcha<br>
2）注册captcha</p>
<p>INSTALLED_APPS = [<br>
'django.contrib.admin',<br>
'django.contrib.auth',<br>
'django.contrib.contenttypes',<br>
'django.contrib.sessions',<br>
'django.contrib.messages',<br>
'django.contrib.staticfiles',<br>
'captcha',<br>
]<br>
也可以个性化定制，在 settings.py中添加如下代码，详情参考官方文档：</p>
<h1 id="设置-captcha-图片大小">设置 captcha 图片大小</h1>
<p>CAPTCHA_IMAGE_SIZE = (80, 45)</p>
<h1 id="字符个数">字符个数</h1>
<p>CAPTCHA_LENGTH = 4</p>
<h1 id="超时minutes">超时(minutes)</h1>
<p>CAPTCHA_TIMEOUT = 1<br>
3）执行数据迁移，生成数据表 captcha_captchastore</p>
<p>python manage.py migrate<br>
4）添加路由</p>
<p>urlpatterns = [<br>
path('admin/', admin.site.urls),<br>
# 图片验证码 路由<br>
path('captcha/', include('captcha.urls'))<br>
]<br>
再添加ajax刷新请求的二级路由，ajxa请求地址： /refresh_captcha/</p>
<p>path('refresh_captcha/', views.refresh_captcha),    # 刷新验证码，ajax<br>
本次django使用的是2.1.8版本，路由的写法可能有点不同，原理一样。</p>
<p>5）在views.py中添加代码，因为在我的项目中，设计到代码的复用问题，所以我创建验证码和验证单独做成函数</p>
<pre><code> 验证码需要导入的模块
from captcha.models import CaptchaStore
from captcha.helpers import captcha_image_url
from django.http import JsonResponse
 
# 创建验证码
def captcha():
    # 验证码，第一次请求
    hashkey = CaptchaStore.generate_key()
    image_url = captcha_image_url(hashkey)
    captcha = {'hashkey': hashkey, 'image_url': image_url}
    return captcha
		
 #验证码API接口
def refresh_captcha(request):
    # 响应
    return JsonResponse(captcha(), content_type='application/json')
 
# 验证验证码
def jarge_captcha(captchaStr, captchaHashkey):
    if captchaStr and captchaHashkey:
        try:
            # 获取根据hashkey获取数据库中的response值
            get_captcha = CaptchaStore.objects.get(hashkey=captchaHashkey) 
            # 如果验证码匹配
            if get_captcha.response == captchaStr.lower():  
                return True
        except:
            return False
    else:
        return False
</code></pre>
<p><strong>前端页面：</strong></p>
<pre><code>&lt;div class=&quot;form-group&quot;&gt;
    &lt;label for=&quot;id_password&quot;&gt;验证码&lt;/label&gt;
    &lt;div id=&quot;captcha_div&quot;&gt;
        &lt;input type=&quot;text&quot; name='captcha' class=&quot;form-control&quot; placeholder=&quot;Captcha&quot; required style=&quot;width: 55%;display: inline-block;margin-right: 8%;&quot;&gt;
        &lt;a href=&quot;#&quot; class=&quot;captcha&quot;&gt;&lt;img src=&quot;{{captcha.image_url}}&quot; alt=&quot;点击换一张&quot; id=&quot;id_captcha&quot;&gt;&lt;/a&gt;
        &lt;input value=&quot;{{captcha.hashkey}}&quot; name=&quot;hashkey&quot; type=&quot;hidden&quot; id=&quot;id_captcha_0&quot;&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p><strong>前端页面显示图片采用 src=&quot;{{captcha.image_url}}&quot;来获取：</strong></p>
<pre><code>&lt;script&gt;
        &lt;!-- 动态刷新验证码js --&gt;
        //网页加载时调用
        $(document).ready(function(){
            //网页加载时发送请求
            $.getJSON(&quot;/refresh_captcha/&quot;, function (result) {
                    $('#id_captcha').attr('src', result['image_url']);
                    $('#id_captcha_0').val(result['hashkey'])
                });
            //点击按钮触发,发送请求
            $('.captcha').click(function () {
                $.getJSON(&quot;/refresh_captcha/&quot;, function (result) {
                    $('#id_captcha').attr('src', result['image_url']);
                    $('#id_captcha_0').val(result['hashkey'])
                });
            });
        });
&lt;/script&gt;
</code></pre>
<p>效果<br>
<img src="https://i.loli.net/2019/09/20/9OueNLHPFosdRyr.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django templates 模板的语法]]></title>
        <id>https://yooinn.github.io//post/django-templates-mo-ban-de-yu-fa</id>
        <link href="https://yooinn.github.io//post/django-templates-mo-ban-de-yu-fa">
        </link>
        <updated>2019-09-20T01:10:22.000Z</updated>
        <content type="html"><![CDATA[<p>MVC 以及 MTV<br>
MVC:<br>
M : model --&gt;&gt; 存取数据(模型)<br>
V: view --&gt;&gt; 信息的展示(视图)<br>
C: controller --&gt;&gt; 逻辑的控制(控制器)<br>
MTV:<br>
M: model --&gt;&gt; ORM操作(模型)<br>
T: template --&gt;&gt; 模板(模板)<br>
V: view --&gt;&gt; 业务逻辑 (视图)<br>
变量<br>
取值顺序 : 字典Key ---&gt;&gt; 属性---&gt;&gt;方法---&gt;&gt;索引<br>
{{ new_name }} ——》 变量 新华出版社 字典或列表用 . 取值<br>
for循环for 标签带有一个可选的{% empty %} 从句，以便在给出的组是空的或者没有被找到时，可以有所操作。<br>
{% for person in person_list %}</p>
<p>{{ person.name }}</p>
<h1 id="循环取值">循环取值</h1>
<p>{% empty %}<br>
<p>sorry,no person here</p>   #  person_list 为空时 显示<br>
{% endfor %}<br>
if 标签 ：{% if %}会对一个变量求值，如果它的值是“True”（存在、不为空、且不是boolean类型的false值），对应的内容块会输出。<br>
{% if i &gt; 300 %}<br>
大于{{ i }}</p>
<p>{% elif i == 200 %}<br>
等于{{ i }}</p>
<p>{% else %}<br>
小于{{ i }}</p>
<p>{% endif %}<br>
.with：使用一个简单地名字缓存一个复杂的变量，当你需要使用一个“昂贵的”方法（比如访问数据库）很多次的时候是非常有用的<br>
{% with total=business.employees.count %}<br>
{{ total }} employee{{ total|pluralize }}<br>
{% endwith %}<br>
{{ person_list.2.name }}</p>
<p>{% with name=person_list.2.name %}<br>
{{ name }}</p>
<p>{% endwith %}<br>
内置过滤器<br>
{{ str|default:'返回值' }} ----&gt;&gt;&gt;&gt; 默认值<br>
{{ str|filesizeformat }} ----&gt;&gt;&gt;&gt; 将文件大小转换为 可读的 类型<br>
{{ str|add:'2' }} ----&gt;&gt;&gt;&gt; 给变量加参数 变量位数字 就加法运算 str 拼接<br>
{{ str|length }} ----&gt;&gt;&gt;&gt; 返回value 的长度<br>
{{ time|data:'Y-m-d H:i:s' }} ----&gt;&gt;&gt;&gt; 时间转换<br>
{{ time|data }} ----&gt;&gt;&gt;&gt; 时间转换 需在 stting 中配置<br>
{{ str|slice:'2:-1' }} ----&gt;&gt;&gt;&gt; 切片<br>
{{ list|first }} ----&gt;&gt;&gt;&gt; 取第一个<br>
{{ list|last }} ----&gt;&gt;&gt;&gt; 取最后一个<br>
{{ list|join:'//' }} ----&gt;&gt;&gt;&gt; 拼接<br>
{{ str|truncatechars:10 }} ----&gt;&gt;&gt;&gt; 截断字符串<br>
{{ html|safa }} ----&gt;&gt;&gt;&gt; 不转义 可写入 html 标签</p>
<p>自定义<br>
定义filter 过滤器<br>
在APP下创建一个叫templatetags的python包； 不能变的，必须是包，名字必须是templatetags<br>
在包中创建一个py文件 my_filters;<br>
在py文件中写代码<br>
from django import template</p>
<p>register = template.Library()  # register的名字不能改<br>
写函数<br>
@register.filter<br>
def add_dsb(value, arg):<br>
return &quot;{}<em>{}&quot;.format(value, arg)<br>
给定义的函数加装饰器<br>
@register.filter<br>
def add_dsb(value, arg):<br>
使用<br>
在模板中使用：<br>
导入定义的文件<br>
{% load my_filter %}<br>
使用过滤器<br>
{{ name|add_dsb:'very_dsb' }}<br>
定义simpletag<br>
和 定义 filter 一样<br>
@register.simple_tags<br>
def add_data(*args,**kwargs):<br>
return &quot;{}</em>{}&quot;.format(&quot;--&quot;.join(args),&quot;*&quot;.join(kwarg.values()))<br>
自定义inclusion_tag<br>
@register.inclusion_tag('show_li.html')<br>
def show_li(num):<br>
return {'num':range(1,num+1)}<br>
写模板 show_li.html</p>
<p>{% for i in num %}<br>
{{ i }}<br>
{% endfor %}</p>
<p>使用:<br>
模板中导入 {% load 定义的py文件名 %}<br>
filter {{ 变量|函数名：参数 }}<br>
simple_tag {{ 变量|函数名：参数 }}<br>
inclusion_tag {% inclusion_tag的函数名 %}<br>
标签<br>
{% csrf_token %}<br>
添加在form表单中 就可以提交POST请求<br>
母版和继承<br>
母版<br>
就是一个普通的HTML文本，将多个页面公共部分的内容提取出来，在页面中定义多个block块<br>
{% block content %}<br>
{% endblock %}<br>
继承<br>
在子页面中，继承母版 {% extends 'base.html' %}<br>
可以重新书写block块中内容<br>
注意事项<br>
{% extends 'base.html' %} 写在第一行，上面不写内容<br>
要修改的 内容写在block块中，写在外面不显示<br>
{% extends 'base.html' %} base.html 记得带上引号，不然当做变量去查找<br>
定义多个block块，一般要定义上 css和js<br>
组件include<br>
{% include 'nav.html' %}<br>
静态文件相关<br>
{% load static %}<br>
{% static '静态文件相对路径' %} ——》 获取到别名，跟后面的参数进行拼接<br>
{% get_static_prefix %} ——》 获取到别名</p>
]]></content>
    </entry>
</feed>